{"sql_stmt_list":{"title":"SQLITE grammar entry point","doc":"[SQLite](https://www.sqlite.org/lang.html)\nAn SQL 'program' is a sequence of SQL statements separated with ;"},"sql_stmt":{"title":"SQL Statements for SQLITE","doc":" [SQLite](https://www.sqlite.org/lang.html)\n - **siud**: SELECT, INSERT, UPDATE, DELETE  \n   - SELECT: Gather table data according to rules   \n   - INSERT: Add new values into table  \n   - UPDATE: Change data in records  \n   - DELETE: suppress table rows \n - **alter-table**:  \n   - RENAME: Change table name.  \n   - ADD new Columns \n - **analyze**: Gathers statistics about tables and indices. \n - **attach**: Adds another database file to the current database connection \n - **begin / commit**: BEGIN starts a Transaction. END finalize a Transaction. Transactions created using BEGIN...COMMIT do not nest.For nested transactions, use the SAVEPOINT and RELEASE commands \n - **create_index**: Create indexes in tables. Indexes allow the database application to find data fast; without reading the whole table \n - **create_table**: Create a table in a database. Tables are organized into rows and columns; and each table must have a name. \n - **create_trigger**: Triggers are database operations that are automatically performed when a specified database event occurs. \n - **create_view**: Create a view in a database. A view Enable filtering and aggregating data coming from one or more table. \n - **detach**: Release a Database previously bound with attach\n - **drop_index**: Remove an index added with the CREATE INDEX statement.\n - **drop_table**: Remove a table added with the CREATE TABLE statement.\n - **drop_trigger**: Remove a trigger created by the CREATE TRIGGER statement.\n - **drop_view**:Remove a view created by the CREATE VIEW statement.\n - **pragma**: Used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data.\n - **reindex**: Used to delete and recreate indices from scratch.\n - **release**: Like a COMMIT for a SAVEPOINT.\n - **rollback**: Revert the state of the database back to what it was just after the corresponding SAVEPOINT.\n - **savepoint**: A method of creating transactions, similar to BEGIN and COMMIT, except that the SAVEPOINT and RELEASE commands are named and may be nested.\n - **vaccum**: Rebuild the database file, repacking it into a minimal amount of disk space. "},"alter_table_stmt":{"title":"Alter Table","doc":"[SQLite](https://www.sqlite.org/lang_altertable.html)\nSQLite supports a limited subset of ALTER TABLE.\nThe only schema altering commands directly supported by SQLite are the \"rename table\" and \"add column\" commands."},"analyze_stmt":{"title":"Analyze","doc":"[SQLite](https://www.sqlite.org/lang_analyze.html)\nANALYZE collects statistics about the contents of tables in the database, and stores the results in the system table.\nSubsequently, the query planner uses these statistics to help determine the most efficient execution plans for queries."},"attach_stmt":{"title":"Attach","doc":"[SQLite](https://www.sqlite.org/lang_attach.html)\nThe ATTACH DATABASE statement adds another database file to the current database connection. \nDatabase files that were previously attached can be removed using the [DETACH DATABASE](#title_sqlite_detach_stmt) command.\nThe schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables.The main and temp databases cannot be attached or detached.\nTables in an attached database can be referred to using the syntax schema-name.table-name. \nIf the name of the table is unique across all attached databases and the main and temp databases, then the schema-name prefix is not required. \nIf two or more tables in different databases have the same name and the schema-name prefix is not used on a table reference, then the table chosen is the one in the database that was least recently attached."},"begin_stmt":{"title":"BEGIN","doc":"[SQLite](https://www.sqlite.org/lang_transaction.html)\nNo changes can be made to the database except within a transaction. Any command that changes the database (basically, any SQL command other than SELECT) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last query finishes.\n\nTransactions can be started manually using the BEGIN command. Such transactions usually persist until the next COMMIT or ROLLBACK command. But a transaction will also ROLLBACK if the database is closed or if an error occurs and the ROLLBACK conflict resolution algorithm is specified. See the documentation on the ON CONFLICT clause for additional information about the ROLLBACK conflict resolution algorithm."},"commit_stmt":{"title":"COMMIT","doc":"[SQLite](https://www.sqlite.org/lang_transaction.html)\nCOMMIT command validate all commands made before the last BEGIN and ends the ongoing transaction."},"rollback_stmt":{"title":"ROLLBACK","doc":"[SQLite](https://www.sqlite.org/lang_transaction.html)\nThe ROLLBACK resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and rolls back the current transaction.\nThe database state is as before this last aborted transaction."},"savepoint_stmt":{"title":"SAVEPOINT","doc":"[SQLite](https://www.sqlite.org/lang_savepoint.html)\nSAVEPOINTs are a method of creating transactions, similar to BEGIN and COMMIT, except that the SAVEPOINT and RELEASE commands are named and may be nested.\n\nThe SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a BEGIN...COMMIT. When a SAVEPOINT is the outer-most savepoint and it is not within a BEGIN...COMMIT then the behavior is the same as BEGIN DEFERRED TRANSACTION."},"release_stmt":{"title":"RELEASE","doc":"[SQLite](https://www.sqlite.org/lang_savepoint.html)\nThe RELEASE command is like a COMMIT for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. \n\nIf a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as COMMIT. The COMMIT command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a BEGIN command."},"create_index_stmt":{"title":"CREATE INDEX","doc":"[SQLite](https://www.sqlite.org/lang_createindex.html)\nThe CREATE INDEX command consists of the keywords \"CREATE INDEX\" followed by the name of the new index, the keyword \"ON\", the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a \"partial index\"."},"indexed_column":{"title":"INDEXED COLUMN","doc":"[SQLite](https://www.sqlite.org/lang_createindex.html)\nName of the column table to be indexed, ascending (ASC) or descending (DESC)"},"create_table_stmt":{"title":"CREATE TABLE","doc":"[SQLite](https://www.sqlite.org/lang_createtable.html)\nThe \"CREATE TABLE\" command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:\n\n - The name of the new table.\n - The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.\n - The name of each column in the table.\n - The declared type of each column in the table.\n - A default value or expression for each column in the table.\n - A default collation sequence to use with each column.\n - Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.\n - A set of SQL constraints for each table. SQLite supports UNIQUE, NOT NULL, CHECK and FOREIGN KEY constraints.\n - Whether the table is a WITHOUT ROWID table."},"column_def":{"title":"COLUMN DEF","doc":"[SQLite](https://www.sqlite.org/lang_createtable.html)\nUnless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more column definitions, optionally followed by a list of table constraints. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional column constraints. Included in the definition of \"column constraints\" for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under SQL Data Constraints below."},"type_name":{"title":"TYPE NAME","doc":"[SQLite](https://www.sqlite.org/datatype3.html#type_conversions_prior_to_comparison)\nMost SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.\n\nSQLite uses a more general dynamic type system. In SQLite, the datatype of a value is associated with the value itself, not with its container. The dynamic type system of SQLite is backwards compatible with the more common static type systems of other database engines in the sense that SQL statements that work on statically typed databases should work the same way in SQLite. However, the dynamic typing in SQLite allows it to do things which are not possible in traditional rigidly typed databases."},"column_constraint":{"title":"COLUMN CONSTRAINT","doc":"[SQLite](https://www.sqlite.org/lang_createtable.html#constraints)\nConstraints are the rules enforced on data columns on table. These are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the database.\n\nConstraints could be column level or table level. Column level constraints are applied only to one column where as table level constraints are applied to the whole table.\n\nFollowing are commonly used constraints available in SQLite.\n\n - NOT NULL Constraint: Ensures that a column cannot have NULL value.\n - DEFAULT Constraint : Provides a default value for a column when none is specified.\n - UNIQUE Constraint: Ensures that all values in a column are different.\n - PRIMARY Key: Uniquely identified each rows/records in a database table.\n - CHECK Constraint: The CHECK constraint ensures that all values in a column satisfy certain conditions."},"signed_number":{"title":"SIGNED NUMBER","doc":"A numeric literal with a + or - prefix"},"table_constraint":{"title":"TABLE CONSTRAINT","doc":"[SQLite](https://www.sqlite.org/lang_createtable.html#constraints)\n\n- Each table in SQLite may have at most one PRIMARY KEY. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column.\n- A UNIQUE constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints.\n- A CHECK constraint may be attached to a column definition or specified as a table constraint.\n- SQL foreign key constraints are used to enforce \"exists\" relationships between tables."},"foreign_key_clause":{"title":"FOREIGN KEY","doc":"[SQLite](https://www.sqlite.org/foreignkeys.html)\n\nForeign keys are used to make reference to rows of a parent table from a child table."},"conflict_clause":{"title":"CONFLICT","doc":"[SQLite](https://sqlite.org/lang_conflict.html)\nThe ON CONFLICT clause is not a separate SQL command. It is a non-standard clause that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar."},"create_trigger_stmt":{"title":"CREATE TRIGGER","doc":"[SQLite](https://sqlite.org/lang_createtrigger.html)\n\nThe CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.\n\nA trigger may be specified to fire whenever a DELETE, INSERT, or UPDATE of a particular database table occurs, or whenever an UPDATE occurs on on one or more specified columns of a table.\n\nAt this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire."},"create_view_stmt":{"title":"CREATE VIEW","doc":"[SQLite](https://www.sqlite.org/lang_createview.html)\nassigns a name to a pre-packaged SELECT statement. Once the view is created, it can be used in the FROM clause of another SELECT in place of a table name.\nYou cannot DELETE, INSERT, or UPDATE a view. Views are read-only in SQLite.\nViews are removed with the DROP VIEW command.\nIf a column-name list follows the view-name, then that list determines the names of the columns for the view."},"create_virtual_table_stmt":{"title":"CREATE VIRTUAL TABLE","doc":"A virtual table is an interface to an external storage or computation engine that appears to be a table but does not actually store information in the database file.\nIn general, you can do anything with a virtual table that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.\nA virtual table is destroyed using the ordinary DROP TABLE statement. There is no DROP VIRTUAL TABLE statement.\nThe module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using sqlite3_create_module() or sqlite3_create_module_v2() prior to issuing the CREATE VIRTUAL TABLE statement."},"common_table_expression":{"title":"COMMON TABLE EXPRESSION","doc":"An ordinary common table expression works as if it were a view that exists for the duration of a single statement. Ordinary common table expressions are useful for factoring out subqueries and making the overall SQL statement easier to read and understand."},"detach_stmt":{"title":"DETACH DATABASE","doc":"This statement detaches an additional database connection previously attached using the ATTACH statement. When not in shared cache mode, it is possible to have the same database file attached multiple times using different names, and detaching one connection to a file will leave the others intact.\n\nIn shared cache mode, attempting to attach the same database file more than once results in an error.\nThis statement will fail if SQLite is in the middle of a transaction."},"drop_index_stmt":{"title":"drop_index_stmt","doc":"drop_index_stmt"},"drop_table_stmt":{"title":"drop_table_stmt","doc":"drop_table_stmt"},"drop_trigger_stmt":{"title":"drop_trigger_stmt","doc":"drop_trigger_stmt"},"drop_view_stmt":{"title":"drop_view_stmt","doc":"drop_view_stmt"},"expr":{"title":"expr","doc":"expr"},"term":{"title":"term","doc":"term"},"raise_function":{"title":"raise_function","doc":"raise_function"},"literal_value":{"title":"literal_value","doc":"literal_value"},"numeric_literal":{"title":"numeric_literal","doc":"numeric_literal"},"string_literal":{"title":"string_literal","doc":"string_literal"},"pragma_stmt":{"title":"pragma_stmt","doc":"pragma_stmt"},"pragma_value":{"title":"pragma_value","doc":"pragma_value"},"reindex_stmt":{"title":"reindex_stmt","doc":"reindex_stmt"},"siud_stmt":{"title":"siud_stmt","doc":"siud_stmt"},"with_clause":{"title":"with_clause","doc":"with_clause"},"cte_table_name":{"title":"cte_table_name","doc":"cte_table_name"},"insert_stmt":{"title":"insert_stmt","doc":"insert_stmt"},"update_stmt":{"title":"update_stmt","doc":"update_stmt"},"delete_stmt":{"title":"delete_stmt","doc":"delete_stmt"},"select_stmt":{"title":"select_stmt","doc":"select_stmt"},"ext_select_stmt":{"title":"ext_select_stmt","doc":"ext_select_stmt"},"select_core":{"title":"select_core","doc":"select_core"},"join_clause":{"title":"join_clause","doc":"join_clause"},"table_or_subquery":{"title":"table_or_subquery","doc":"table_or_subquery"},"result_column":{"title":"result_column","doc":"result_column"},"join_operator":{"title":"join_operator","doc":"join_operator"},"join_constraint":{"title":"join_constraint","doc":"join_constraint"},"ordering_term":{"title":"ordering_term","doc":"ordering_term"},"compound_operator":{"title":"compound_operator","doc":"compound_operator"},"qualified_table_name":{"title":"qualified_table_name","doc":"qualified_table_name"},"vacuum_stmt":{"title":"vacuum_stmt","doc":"vacuum_stmt"},"name":{"title":"name","doc":"name"},"database_name":{"title":"database_name","doc":"database_name"},"table_name":{"title":"table_name","doc":"table_name"},"column_name":{"title":"column_name","doc":"column_name"},"index_name":{"title":"index_name","doc":"index_name"},"trigger_name":{"title":"trigger_name","doc":"trigger_name"},"view_name":{"title":"view_name","doc":"view_name"},"pragma_name":{"title":"pragma_name","doc":"pragma_name"},"binary_operator":{"title":"binary_operator","doc":"binary_operator"},"unary_operator":{"title":"unary_operator","doc":"unary_operator"},"function_name":{"title":"function_name","doc":"function_name"},"column_alias":{"title":"column_alias","doc":"column_alias"},"new_table_name":{"title":"new_table_name","doc":"new_table_name"},"savepoint_name":{"title":"savepoint_name","doc":"savepoint_name"},"table_or_index_name":{"title":"table_or_index_name","doc":"table_or_index_name"},"module_name":{"title":"module_name","doc":"module_name"},"module_argument":{"title":"module_argument","doc":"module_argument"},"collation_name":{"title":"collation_name","doc":"collation_name"},"gendoc":"[SQLite](https://www.sqlite.org/about.html) is an in-process library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. \nThe code for SQLite is in the public domain and is thus free for use for any purpose, commercial or private. \nSQLite is the most widely deployed database in the world with more applications than we can count, including several high-profile projects.\n\nSQLite is an embedded SQL database engine. Unlike most other SQL databases, SQLite does not have a separate server process. \nSQLite reads and writes directly to ordinary disk files. \nA complete SQL database with multiple tables, indices, triggers, and views, is contained in a single disk file. \nThe database file format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures. \nThese features make SQLite a popular choice as an Application File Format. \n\nThink of SQLite not as a replacement for Oracle but as a replacement for fopen()\n\n*Note: one can click on each Non Terminal rule (rectangle) of a syntax diagram to go and see the definition.*"}