<html>
<head>
<link rel="stylesheet" href="codemirror.css">
<link rel="stylesheet" href="foldgutter.css">
<script src="codemirror.js"></script>
<script src="matchbrackets.js"></script>
<script src="continuecomment.js"></script>
<script src="comment.js"></script>
<script src="foldcode.js"></script>
<script src="javascript.js"></script>
<script src="sql.js"></script>
<script src="foldgutter.js"></script>
<script src="brace-fold.js"></script>
<script src="json-formatter-js.js"></script>
<script src="railroad.js"></script>
<script src="jslint.js"></script>
<script>
window.expressionsource="/********************************************************************************************************************************/ \n \
 Show(Sequence(Title('expression'),OneOrMore(NonTerminal('term'),Terminal('+')), Comment('END expression')) /* Sequence */ \n \
 ); /* expression */ \n \
/********************************************************************************************************************************/ \n \
 Show(Sequence(Title('term'),OneOrMore(NonTerminal('factor'),Terminal('*')), Comment('END term')) /* Sequence */ \n \
 ); /* term */ \n \
/********************************************************************************************************************************/ \n \
 Show(Stack(Title('factor'),Sequence(Choice(0, \n \
                                   NonTerminal('constant'), \n \
                                   NonTerminal('variable'), \n \
                                   Sequence(Terminal('('),NonTerminal('expression'),Terminal(')')) \n \
                                  )) \n \
            , Comment('END factor')) /* Stack */ \n \
 ); /* factor */ \n \
/********************************************************************************************************************************/ \n \
 Show(Sequence(Title('variable'),Terminal('/[A-Z][A-Za-z0-9_]*/'), Comment('END variable')) /* Sequence */ \n \
 ); /* variable */ \n \
/********************************************************************************************************************************/ \n \
 Show(Sequence(Title('constant'),Terminal('/[+-]?[0-9]+/'), Comment('END constant')) /* Sequence */ \n \
 ); /* constant */ \n";
window.createtablesource= "/********************************************************************************************************************************/ \n \
Show(Stack(Title('CREATE TABLE'), \n \
  Sequence(Terminal('CREATE'),Choice(0,Skip(),Terminal('TEMP'),Terminal('TEMPORARY')),Terminal('TABLE'), \n \
           Choice(0,Skip(),Sequence(Terminal('IF'),Terminal('NOT'),Terminal('EXISTS')) \n \
  ) /* sequence */ \n \
),Sequence(Optional(Sequence(NonTerminal('schema-name'),Terminal('.'))),NonTerminal('table-name')), /* sequence */ \n \
Sequence( \n \
 Choice(0, \n \
  Sequence(Terminal('('),OneOrMore(NonTerminal('column-def'),Terminal(',')), \n \
           ZeroOrMore(Terminal(','),NonTerminal('table-constraint')), \n \
           Terminal(')'),Optional(Sequence(Terminal('WITHOUT'),Terminal('ROWID')))), \n \
  Sequence(Terminal('AS'),NonImplemented('select-stm')) \n \
 ) /* choice */ \n \
), \n \
Comment('END CREATE TABLE')) /* Stack */ \n \
); /* Create Table */ \n \
/********************************************************************************************************************************/ \n \
Show( \n \
Sequence(Title('schema-name'), \n \
NonTerminal('name'),Comment('END schema-name') \n \
)  \n \
); /* schema name */ \n \
/********************************************************************************************************************************/ \n \
Show( \n \
Sequence(Title('table-name'),NonTerminal('name'),Comment('END table-name') \n \
) \n \
); /* tables name */ \n \
/********************************************************************************************************************************/ \n \
Show( \n \
Sequence(Title('column-def'),NonTerminal('column-name'),Optional(NonTerminal('type-name')),ZeroOrMore(NonTerminal('column-constraint')), \n \
Comment('END column-def') \n \
) \n \
); /* column def */ \n \
/********************************************************************************************************************************/ \n \
Show( \n \
Sequence(Title('column-name'),NonTerminal('name'),Comment('END column-name') \n \
) \n \
); /* column name */ \n \
/********************************************************************************************************************************/ \n \
Show( \n \
Sequence(Title('name'), \n \
Choice(0, \n \
	Terminal('/(^[A-Za-z][A-Za-z0-9_]*)/'), \n \
	Terminal('/(^\\\"[A-Za-z][A-Za-z0-9_\\s]*)\\\"/'), \n \
        Terminal(\"/(^\\'[A-Za-z][A-Za-z0-9_\\s]*)\\'/\") \n \
), \n \
Comment('END name') \n \
) \n \
); /* name */ \n \
/********************************************************************************************************************************/ \n \
Show(Stack( \n \
  Title('column-constraint'), \n \
  Optional(Sequence(Terminal('CONSTRAINT'),NonTerminal('name'))), \n \
  Sequence(Choice(0, \n \
         Sequence(Terminal('PRIMARY'),Terminal('KEY'),Choice(0,Skip(),Terminal('ASC'),Terminal('DESC')),NonTerminal('conflict-clause'),Optional(Terminal('AUTOINCREMENT'))), \n \
         Sequence(Optional(Terminal('NOT')),Terminal('NULL'),NonTerminal('conflict-clause')), \n \
         Sequence(Terminal('UNIQUE'),NonTerminal('conflict-clause')), \n \
         Sequence(Terminal('CHECK'),Terminal('('),NonImplemented('expr'),Terminal(')')), \n \
         Sequence(Terminal('DEFAULT'),Choice(0,NonTerminal('signed-number'),NonTerminal('literal-value'),Sequence(Terminal('('),NonImplemented('expr'),Terminal(')')))), \n \
         Sequence(Terminal('COLLATE'),Terminal('collation-name')), \n \
         NonTerminal('foreign-key-clause') \n \
        )), \n \
  Comment('END column-constraint') \n \
  ) \n \
); /* column-constraint */ \n \
/********************************************************************************************************************************/ \n \
Show(Sequence(Title('conflict-clause'), \n \
     Optional(Sequence(Terminal('ON'),Terminal('CONFLICT'), \n \
                                                Choice(0, \n \
                                                       Terminal('ROLLBACK'), \n \
                                                       Terminal('ABORT'), \n \
                                                       Terminal('FAIL'), \n \
                                                       Terminal('IGNORE'), \n \
                                                       Terminal('REPLACE')) \n \
                                               ) \n \
                                      ),Comment('END conflict-clause')) \n \
    ); /* conflict-clause */ \n \
/********************************************************************************************************************************/ \n \
Show(Stack(Title('table-constraint'),Stack(Optional(Sequence(Terminal('CONSTRAINT'),NonTerminal('name'))), \n \
                                     Choice(0,Sequence(Choice(0,Sequence(Terminal('PRIMARY'),Terminal('Key')),Terminal('UNIQUE')),Terminal('('), \n \
                                                       OneOrMore(NonTerminal('indexed-column'),Terminal(',')),Terminal(')'),NonTerminal('conflict-clause')), \n \
                                            Sequence(Terminal('CHECK'),Terminal('('),NonImplemented('expr'),Terminal(')')), \n \
                                            Sequence(Terminal('FOREIGN'),Terminal('KEY'),Terminal('('), \n \
                                                     OneOrMore(NonTerminal('column-name'),Terminal(',')),Terminal(')'), \n \
                                                     NonTerminal('foreign-key-clause')) \n \
                                           )                                           \n \
     ), \n \
     Comment('END table-constrainte')) \n \
); /* table-constraint */ \n \
/********************************************************************************************************************************/ \n \
Show(Stack(Title('indexed-column'), \n \
     Sequence(Choice(0,NonTerminal('column-name'),NonImplemented('expr')), \n \
              Optional(Sequence(Terminal('COLLATE'),NonTerminal('collation-name'))), \n \
              Choice(0,Skip(),Terminal('ASC'),Terminal('DESC'))), \n \
     Comment('END indexed-column')) \n \
    ); /* indexed-column */ \n \
/********************************************************************************************************************************/ \n \
Show(Stack(Title('type-name'), \n \
           Sequence(NonTerminal('name'),Choice(0, \n \
                                                Skip(), \n \
                                                Sequence(Terminal('('),NonTerminal('signed-number'),Terminal(')')), \n \
                                                Sequence(Terminal('('),NonTerminal('signed-number'),Terminal(','),NonTerminal('signed-number'),Terminal(')')) \n \
                                               ) \n \
                   ), \n \
           Comment('END type-name')) \n \
    ); /* type-name */  \n \
/********************************************************************************************************************************/ \n \
Show(Stack(Title('numeric-literal'), \n \
           Sequence(Choice(0,Choice(0,Sequence(Choice(0,Sequence(Terminal('/[0-9]+/'),Optional(Sequence(Terminal('.'),Terminal('/[0-9]+/')))), \n \
                                                      Sequence(Terminal('.'),Terminal('/[0-9]+/')) \n \
                                                     ), \n \
                                               Optional(Sequence(Terminal('E'), \n \
                                                                 Choice(0,Skip(),Terminal('+'),Terminal('-')),Terminal('/[0-9]+/'))) \n \
                                              ) \n \
                                   ), \n \
                           Sequence(Terminal('0x'),Terminal('/[A-Za-z0-9]+)/')) \n \
                          ) \n \
                   ), \n \
           Comment('END numeric-literal')) \n \
    ); /* numeric-literal */ \n \
/********************************************************************************************************************************/ \n \
Show(Sequence(Title('signed-number'),Optional(Choice(0,Terminal('+'),Terminal('-'))),NonTerminal('numeric-literal'),Comment('END signed-number')) \n \
    ); /* signed-number */  \n \
/********************************************************************************************************************************/ \n \
Show(Stack(Title('foreign-key-clause'), \n \
           Sequence(Terminal('REFERENCES'),NonTerminal('foreign-table'), \n \
                    Optional(Sequence(Terminal('('),OneOrMore(NonTerminal('column-name'),Terminal(',')),Terminal(')')))), \n \
           Stack(ZeroOrMore( \n \
                          Choice(0, \n \
                                 Sequence(Terminal('ON'), \n \
                                          Choice(0,Terminal('DELETE'),Terminal('UPDATE')), \n \
                                          Choice(0, \n \
                                                 Sequence(Terminal('SET'),Choice(0,Terminal('NULL'),Terminal('DEFAULT'))), \n \
                                                 Terminal('CASCADE'), \n \
                                                 Terminal('RESTRICT'), \n \
                                                 Sequence(Terminal('NO'),Terminal('ACTION')) \n \
                                                ) \n \
                                         ), \n \
                                 Sequence(Terminal('MATCH'),NonTerminal('name')) \n \
                                ) \n \
                          ), \n \
                          Optional(Sequence(Optional(Terminal('NOT')),Terminal('DEFERRABLE'), \n \
                                           Choice(0,Skip(),Sequence(Terminal('INITIALLY'), \n \
                                                                    Choice(0,Terminal('DEFFERED'),Terminal('IMMEDIATE')) \n \
                                                                   ) \n \
                                                 ) \n \
                                           ) \n \
                                  ) \n \
                   ), \n \
           Comment('END foreign-key-clause') \n \
          ) \n \
    ); /* foreign-key-clause */ \n \
/********************************************************************************************************************************/ \n \
Show(Sequence(Title('foreign-table'),NonTerminal('table-name'),Comment('END foreign-table')) \n \
    ); /* foreign-table */ ";

/* user application */
root.context =	{
		title:"notset",
		href:true,
		dochref:"doc"
	};
root.Railroad.call(this,root,
	{ // those will be Diagram options
	VERTICAL_SEPARATION: 8,
	ARC_RADIUS: 10,
	DIAGRAM_CLASS: 'railroad-diagram',
	STROKE_ODD_PIXEL_LENGTH: true,
	INTERNAL_ALIGNMENT: 'center',
	},
	root.context
);
</script>
<style>
.hidden{
	display: none;
}
a.svg {
  position: relative;
  display: inline-block;
}
svg.railroad-diagram {
    background-color: hsl(30,20%,95%);
}
svg.railroad-diagram path {
    stroke-width: 3;
    stroke: black;
    fill: rgba(0,0,0,0);
}
svg.railroad-diagram text {
    font: bold 14px monospace;
    text-anchor: middle;
}
svg.railroad-diagram text.diagram-text {
    font-size: 12px;
}
svg.railroad-diagram text.diagram-arrow {
    font-size: 16px;
}
svg.railroad-diagram text.label {
    text-anchor: start;
}
svg.railroad-diagram text.comment {
    font: italic 12px monospace;
}
svg.railroad-diagram g.non-terminal text {
    /*font-style: italic;*/
}
svg.railroad-diagram rect {
    stroke-width: 3;
    stroke: black;
    fill: hsl(120,100%,90%);
}
svg.railroad-diagram path.diagram-text {
    stroke-width: 3;
    stroke: black;
    fill: white;
    cursor: help;
}
svg.railroad-diagram g.diagram-text:hover path.diagram-text {
    fill: #eee;
}
input[type=checkbox]:checked + div {
  display: none;
}
.homeLink{
  background-color: #E4F5F8;
  border:1px solid #C0DEED; 
  text-decoration:none; 
}
header,
section,
aside,
nav,
footer {
  /* margin: 0 1.5% 24px 1.5%; */
}
section {
  float: left;
  width: 63%;
}
aside {
  float: right;
  width: 30%;
}
header{
  color:white;
  background-color:lightgrey;	
}
footer {
  clear: both;
  margin-bottom: 0;
  color:white;
  background-color:grey;
}
</style>
</head>
<body  onload="refresh()">
<div class="container">

<header>
<h1>railroad-diagram</h1>
</header>
<nav>
<button id="createtable" onclick="createtable();">Create Table</button>
<button id="expression" onclick="expression();">expression</button>
<button id="showhide" onclick="showhide();">show/hide</button>
<select id="items" onchange="goToItem()"></select>
<button id="switch" onclick="doswitch();">switch</button>
<button id="validate" onclick="dovalidate();">validate</button>
<button id="refresh" onclick="refresh();">refresh</button>
</nav>
<div>
<input type='checkbox' id='home'/>home(+/-)<div>
<div id="editor">
<textarea id="graphin" cols='150' rows='25'>
/********************************************************************************************************************************/
Show(Stack(Title("CREATE TABLE"),
  Sequence(Terminal('CREATE'),Choice(0,Skip(),Terminal('TEMP'),Terminal('TEMPORARY')),Terminal('TABLE'),
           Choice(0,Skip(),Sequence(Terminal('IF'),Terminal('NOT'),Terminal('EXISTS'))
  ) /* sequence */
),Sequence(Optional(Sequence(NonTerminal('schema-name'),Terminal("."))),NonTerminal('table-name')), /* sequence */
Sequence(
 Choice(0,
  Sequence(Terminal("("),OneOrMore(NonTerminal("column-def"),Terminal(",")),
           ZeroOrMore(Terminal(","),NonTerminal("table-constraint")),
           Terminal(")"),Optional(Sequence(Terminal("WITHOUT"),Terminal("ROWID")))),
  Sequence(Terminal("AS"),NonImplemented("select-stm"))
 ) /* choice */
),
Comment("END CREATE TABLE")) /* Stack */
); /* Create Table */
/********************************************************************************************************************************/
Show(
Sequence(Title("schema-name"),
NonTerminal('name'),Comment("END schema-name")
) 
); /* schema name */
/********************************************************************************************************************************/
Show(
Sequence(Title("table-name"),NonTerminal('name'),Comment('END table-name')
)
); /* tables name */
/********************************************************************************************************************************/
Show(
Sequence(Title("column-def"),NonTerminal("column-name"),Optional(NonTerminal("type-name")),ZeroOrMore(NonTerminal("column-constraint")),
Comment("END column-def")
)
); /* column def */
/********************************************************************************************************************************/
Show(
Sequence(Title("column-name"),NonTerminal('name'),Comment('END column-name')
)
); /* column name */
/********************************************************************************************************************************/
Show(
Sequence(Title("name"),
Choice(0,
	Terminal('/(^[A-Za-z][A-Za-z0-9_]*)/'),
	Terminal('/(^\\"[A-Za-z][A-Za-z0-9_\\s]*)\\"/'),
        Terminal("/(^\\'[A-Za-z][A-Za-z0-9_\\s]*)\\'/")
),
Comment("END name")
)
); /* name */
/********************************************************************************************************************************/
Show(Stack(
  Title("column-constraint"),
  Optional(Sequence(Terminal("CONSTRAINT"),NonTerminal("name"))),
  Sequence(Choice(0,
         Sequence(Terminal("PRIMARY"),Terminal("KEY"),Choice(0,Skip(),Terminal("ASC"),Terminal("DESC")),NonTerminal("conflict-clause"),Optional(Terminal("AUTOINCREMENT"))),
         Sequence(Optional(Terminal("NOT")),Terminal("NULL"),NonTerminal("conflict-clause")),
         Sequence(Terminal("UNIQUE"),NonTerminal("conflict-clause")),
         Sequence(Terminal("CHECK"),Terminal("("),NonImplemented("expr"),Terminal(")")),
         Sequence(Terminal("DEFAULT"),Choice(0,NonTerminal("signed-number"),NonTerminal("literal-value"),Sequence(Terminal("("),NonImplemented("expr"),Terminal(")")))),
         Sequence(Terminal("COLLATE"),Terminal("collation-name")),
         NonTerminal("foreign-key-clause")
        )),
  Comment("END column-constraint")
  )
); /* column-constraint */
/********************************************************************************************************************************/
Show(Sequence(Title("conflict-clause"),
     Optional(Sequence(Terminal("ON"),Terminal("CONFLICT"),
                                                Choice(0,
                                                       Terminal("ROLLBACK"),
                                                       Terminal("ABORT"),
                                                       Terminal("FAIL"),
                                                       Terminal("IGNORE"),
                                                       Terminal("REPLACE"))
                                               )
                                      ),Comment("END conflict-clause"))
    ); /* conflict-clause */
/********************************************************************************************************************************/
Show(Stack(Title("table-constraint"),Stack(Optional(Sequence(Terminal("CONSTRAINT"),NonTerminal("name"))),
                                     Choice(0,Sequence(Choice(0,Sequence(Terminal("PRIMARY"),Terminal("Key")),Terminal("UNIQUE")),Terminal("("),
                                                       OneOrMore(NonTerminal("indexed-column"),Terminal(",")),Terminal(")"),NonTerminal("conflict-clause")),
                                            Sequence(Terminal("CHECK"),Terminal("("),NonImplemented("expr"),Terminal(")")),
                                            Sequence(Terminal("FOREIGN"),Terminal("KEY"),Terminal("("),
                                                     OneOrMore(NonTerminal("column-name"),Terminal(",")),Terminal(")"),
                                                     NonTerminal("foreign-key-clause"))
                                           )                                          
     ),
     Comment("END table-constrainte"))
); /* table-constraint */
/********************************************************************************************************************************/
Show(Stack(Title("indexed-column"),
     Sequence(Choice(0,NonTerminal("column-name"),NonImplemented("expr")),
              Optional(Sequence(Terminal("COLLATE"),NonTerminal("collation-name"))),
              Choice(0,Skip(),Terminal("ASC"),Terminal("DESC"))),
     Comment("END indexed-column"))
    ); /* indexed-column */
/********************************************************************************************************************************/
Show(Stack(Title("type-name"),
           Sequence(NonTerminal("name"),Choice(0,
                                                       Skip(),
                                                       Sequence(Terminal("("),NonTerminal("signed-number"),Terminal(")")),
                                                       Sequence(Terminal("("),NonTerminal("signed-number"),Terminal(","),NonTerminal("signed-number"),Terminal(")"))
                                                      )
                   ),
           Comment("END type-name"))
    ); /* type-name */ 
/********************************************************************************************************************************/
Show(Stack(Title("numeric-literal"),
           Sequence(Choice(0,Choice(0,Sequence(Choice(0,Sequence(Terminal("/[0-9]+/"),Optional(Sequence(Terminal("."),Terminal("/[0-9]+/")))),
                                                      Sequence(Terminal("."),Terminal("/[0-9]+/"))
                                                     ),
                                               Optional(Sequence(Terminal("E"),
                                                                 Choice(0,Skip(),Terminal("+"),Terminal("-")),Terminal("/[0-9]+/")))
                                              )
                                   ),
                           Sequence(Terminal("0x"),Terminal("/[A-Za-z0-9]+)/"))
                          )
                   ),
           Comment("END numeric-literal"))
    ); /* numeric-literal */
/********************************************************************************************************************************/
Show(Sequence(Title("signed-number"),Optional(Choice(0,Terminal("+"),Terminal("-"))),NonTerminal("numeric-literal"),Comment("END signed-number"))
    ); /* signed-number */ 
/********************************************************************************************************************************/
Show(Stack(Title("foreign-key-clause"),
           Sequence(Terminal("REFERENCES"),NonTerminal("foreign-table"),
                    Optional(Sequence(Terminal("("),OneOrMore(NonTerminal("column-name"),Terminal(",")),Terminal(")")))),
           Stack(ZeroOrMore(
                          Choice(0,
                                 Sequence(Terminal("ON"),
                                          Choice(0,Terminal("DELETE"),Terminal("UPDATE")),
                                          Choice(0,
                                                 Sequence(Terminal("SET"),Choice(0,Terminal("NULL"),Terminal("DEFAULT"))),
                                                 Terminal("CASCADE"),
                                                 Terminal("RESTRICT"),
                                                 Sequence(Terminal("NO"),Terminal("ACTION"))
                                                )
                                         ),
                                 Sequence(Terminal("MATCH"),NonTerminal("name"))
                                )
                          ),
                          Optional(Sequence(Optional(Terminal("NOT")),Terminal("DEFERRABLE"),
                                           Choice(0,Skip(),Sequence(Terminal("INITIALLY"),
                                                                    Choice(0,Terminal("DEFFERED"),Terminal("IMMEDIATE"))
                                                                   )
                                                 )
                                           )
                                  )
                   ),
           Comment("END foreign-key-clause")
          )
    ); /* foreign-key-clause" */
/********************************************************************************************************************************/
Show(Sequence(Title("foreign-table"),NonTerminal("table-name"),Comment("END foreign-table"))
    ); /* foreign-table */
</textarea>
</div >
<div id="sql">
<textarea id="sqleditor" cols="50" rows="25">
CREATE TABLE "Customer" (
  "IdCustomer" text NULL PRIMARY KEY,
  "CompanyName" text NULL,
  "ContactName" text NULL,
  "ContactTitle" text NULL,
  "Address" text NULL,
  "City" text NULL,
  "Region" text NULL,
  "PostalCode" text NULL,
  "Country" text NULL,
  "Phone" text NULL,
  "Fax" text NULL
)
</textarea>
<div id="sqlcompiled">
</div>
</div>
</div>
<div id="error">
</div>
<div id="result">
</div>
<footer>Copyright &copy; Gilbert Brault 2016</footer>
<script>

window.editor = CodeMirror.fromTextArea(document.getElementById("graphin"), {
		mode: "javascript",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter",       
});

window.sql = CodeMirror.fromTextArea(document.getElementById("sqleditor"), {
		mode: "sql",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter",       
});

var cmsql = document.getElementById("sql");
cmsql.setAttribute("class","hidden");
window.showstate="editor";
var validate=document.getElementById("validate");
validate.setAttribute("class","hidden");

function createtable(){
	window.editor.getDoc().setValue(window.createtablesource);
}

function expression(){
	window.editor.getDoc().setValue(window.expressionsource);
}

function injectjs(content,error){
    var scriptref=document.createElement('script');
    scriptref.setAttribute("type","text/javascript");
    scriptref.innerText= content;
    if ((typeof scriptref!="undefined") && scriptref!=null){
    	try{
        	document.getElementsByTagName("head")[0].appendChild(scriptref);
    	} 	catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
    }
    return scriptref;
}

function _Show(){
	if(this.state==="graphing"){
		try{		
			this.graph.push ((new Diagram([].slice.call(arguments))).format());
		}  	catch(e){
			this.error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
		this.title.push(this.context.title);
		this.context.title="notset";
	} else if(this.state==="walking"){
		this.walk.push (Diagram(arguments[0]));
	}
}

function refresh(){
	var error=document.getElementById('error');
	var result=document.getElementById('result');
	var select=document.getElementById('items');
	window.results={title:[],graph:[],walk:[],context:root.context,state:"notset",error:error};
	window.Show=_Show.bind(window.results);
	result.innerHTML="";
	error.innerHTML="";
	select.innerHTML="";
	var diags = window.editor.getValue();
	var scriptref;

	//jslint for errors
	var source = diags;
	source+="\nfunction Show(){}\n";
	for(var fn=0; fn<root.Railroad.fnames.length;fn++){
		source+="\nfunction "+root.Railroad.fnames[fn]+"(){}\n";
	}
	var jscheck = jslint(source);

	if(!jscheck.stop){

	// prepare graphing
	results.state='graphing';
	root.Railroad.SetExports(root.Railroad.graphing,root.Railroad.fnames);
	// comments should be within /* */  double // don't work
	try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}      
	scriptref.outerHTML="";

	// prepare json
	results.state='walking';
    root.Railroad.SetExports(root.Railroad.walking,root.Railroad.fnames);
    	try{
		scriptref = injectjs(diags);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";

    // render results
    for(var i=0; i<results.graph.length;i++){
    		var section = document.createElement('section');
	        // show/hide
	        var home=document.createElement('a');
	        home.setAttribute("href","#");
	        home.setAttribute("onclick","home()");
	        home.setAttribute("class","homeLink");
	        home.setAttribute("title","jump to top");
	        var lhome=document.createTextNode("^");
	        home.appendChild(lhome);
	        section.appendChild(home);           
    		var checkbox = document.createElement('input');
			checkbox.type = "checkbox";
			section.appendChild(checkbox);
			var clabel= ((results.title[i]!=="notset")?results.title[i]:"")+" (+/-)";
			if(context.title!=="notset"){
            	checkbox.setAttribute("id",results.title[i]);
            	var option = document.createElement("option");
				option.text = results.title[i];
				select.add(option);
        	} 
        	var label=document.createTextNode(clabel);
        	section.appendChild(label);
        	var div = document.createElement('div');
        	section.appendChild(div);
        	if(i<results.graph.length-1)
        		checkbox.checked=true;

    		// graphing
			var graphout = document.createElement('aside');           
            graphout.appendChild(results.graph[i].toSVG());           
            div.appendChild(graphout);    	
			// json tree
		    const formatter = new JSONFormatter(results.walk[i]);
            var elt = formatter.render();
            var walkout = document.createElement('article');                       
            walkout.appendChild(elt);
            div.appendChild(walkout);
			result.appendChild(section);
    } 
	} else {
		// display warnings
		var content="<pre>";		
		for(var i=0; i<jscheck.warnings.length; i++){
			var w = jscheck.warnings[i];
			content+=w.line+":"+w.column+" "+w.message+"\n";
		}
		content+="</pre>";
		error.innerHTML=content;
	}        
}

function showhide(){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		chkbx.checked = ! chkbx.checked;
	}
}

function home(){
	document.getElementById("home").scrollIntoView();  
}

function scrollto(h){
	document.getElementById(h).scrollIntoView();  
}

function goToItem(){
	var select = document.getElementById("items");
	var item = select.value;
	_goToItem(item);
}

function _goToItem(item){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		if(item!=window.results.title[i]){
			chkbx.checked = true;
		} else {
			chkbx.checked = false;
		}
		
	}	
}

function doc(type,node){
	if(type==="NonTerminal"){
		_goToItem(node);
	}
}

function tokenizer(str){
/* add characters if more needed*/
const regex = /"(?:\w|\s)+"|'(?:\w|\s)+'|\w+|[,.()\+\-\*/;]/gm;
var m;
var results=[];

while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
        regex.lastIndex++;
    }
    
    // The result can be accessed through the `m`-variable.
    m.forEach((match, groupIndex) => {
        // console.log(`Found match, group ${groupIndex}: ${match}`);
        results.push(match);
    });
}
return results;	
}

function fillerrorstack(context){
	if(context.error!==undefined){
		var esindex = context.errorstack.length-1;
		if( (esindex!==-1) &&
		   (context.errorstack[esindex].state==context.error.state) &&
		   (context.errorstack[esindex].message==context.error.message)
		  ) return;
		context.errorstack.push({state:context.error.state,message:context.error.message});
	}
}

function doswitch(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var cmsql=document.getElementById("sql");
	var cmrailroad=document.getElementById("editor");
	var validate=document.getElementById("validate");
	var refresh=document.getElementById("refresh");

    if(window.showstate==="editor"){
		cmsql.setAttribute("class","");
		cmrailroad.setAttribute("class","hidden");
		validate.setAttribute("class","");
		refresh.setAttribute("class","hidden");
		window.showstate="sql";
	} else if(window.showstate==="sql"){
		cmsql.setAttribute("class","hidden");
		cmrailroad.setAttribute("class","");
		validate.setAttribute("class","hidden");
		refresh.setAttribute("class","");	
		window.showstate="editor";		
	}
}

function dovalidate(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var sql = window.sql.getValue();
	var tokens = tokenizer(sql);
	var i;
	var walk;
	// now check if the path i.e. the tokens list is compatible with the selected graph
	// find the entry graph
    var select = document.getElementById("items");
	var item = select.value;
	for(i=0; i<window.results.title.length;i++){
		if(item===window.results.title[i]) break;
	}
	if(i<window.results.title.length){
		walk = window.results.walk[i];
		var walkindex = 0;
		var pathindex = 0;
		var context = {path:tokens,pathindex:pathindex,walk:walk,walkindex:walkindex,titles:[item]};
		context.nonTerminals={};
		for(i=0; i<window.results.title.length;i++){
			context.nonTerminals[window.results.title[i]]=window.results.walk[i];
		}
		dowalk(context);
		var final={};
		final[item]=context.compiled;
		context.compiled=[];
		context.compiled.push(final);
		if(context.error===undefined){
			// displayed 'compiled' structure		
		    const formatter = new JSONFormatter(context.compiled);
            var elt = formatter.render();
            sqlcompiled.appendChild(elt);
		} else{
			// display error and errorstack
			error.innerHTML=context.error.message;
			const formatter = new JSONFormatter(context.errorstack);
			var elt = formatter.render();
			error.appendChild(elt);
		}
	}
	return false;
}

function fillcompiled(context,compiled,nt){
	if(nt===undefined){
		if((Array.isArray(context.compiled) && (context.compiled.length>0))){
			if(context.compiled.length==1){
				compiled.push(context.compiled[0]);
			} else{
				compiled.push(context.compiled);
			}
		}
	} else if (!Array.isArray(context.compiled)){
		var keys = Object.keys(context.compiled);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(context.compiled[keys[i]])){
				if(context.compiled[keys[i]].length==1){
					context.compiled[keys[i]]= context.compiled[keys[i]][0];
				} else if(context.compiled[keys[i]].length==0){
					delete(context.compiled[keys[i]]);
				}
			}
		}
		if(Array.isArray(context.compiled)||(Object.keys(context.compiled).length!=0)){
			compiled.push(context.compiled);	
		}			
	} else{
		var keys = Object.keys(nt);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(nt[keys[i]])){
				if(nt[keys[i]].length==1){
					nt[keys[i]]= nt[keys[i]][0];
				} else if(nt[keys[i]].length==0){
					delete(nt[keys[i]]);
				}
			}
		}
		if(Array.isArray(nt)||(Object.keys(nt).length!=0)){
			compiled.push(nt);
		}		
	}
}

function dowalk(context){
	if (context.walkindex>Object.keys(context.walk).length) return;
	var walknodetype = Object.keys(context.walk)[context.walkindex];
	// context.errorstack=[];  // reset errorstack as it's relevant just for the current case (not global)
	switch(walknodetype){
		case 'Diagram':
			if(context.titles===undefined){
		    	context.titles=[];
		    }
			if(context.compiled===undefined){
				context.compiled = [];
			}
		    if (context.stack===undefined){
		    	context.stack = [];
		    }
		    if (context.errorstack===undefined){
		    	context.errorstack = [];
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk['Diagram'][0];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    return;
			break;
		case 'Title':
		    context.walkindex++;
		    break;
		 case 'Comment':
		    context.walkindex++;
		    break;	
		 case 'NonTerminal':
		  	var compiled = context.compiled;	
		  	var ntname=context.walk["NonTerminal"][0];
		  	// console.log(ntname);
		  	context.titles.push(ntname);
		    if(context.nonTerminals[context.walk["NonTerminal"][0]]===undefined){
		    	context.error={state:true,message:"not existing NonTerminal"+context.walk["NonTerminal"][0]};
		    	break;
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walk=context.nonTerminals[context.walk["NonTerminal"][0]];
		    var nt ={};
		    nt[ntname]=context.compiled=[];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    if(context.error===undefined) {
		    	fillcompiled(context,compiled,nt);	    		
		    }
		    context.compiled=compiled;
		    context.titles.pop();
		 	break;		    	 	
		 case 'Terminal':
		 	var compiled = context.compiled;	
		    if(context.pathindex<context.path.length){
		    	if(context.walk.Terminal[0].startsWith("/")){
		    		var l = context.walk.Terminal[0].length;
                  	const regex = new RegExp(context.walk.Terminal[0].substring(1,l-1));
					var m;

					if ((m = regex.exec(context.path[context.pathindex])) !== null) {
    					// The result can be accessed through the `m`-variable.
    					// m.forEach((match, groupIndex) => {
        					// console.log(`Found match, group ${groupIndex}: ${match}`);
    					// });
    					fillcompiled(context,compiled,context.path[context.pathindex]);
					} else {
						context.error={state:true,message:"Terminal "+context.path[context.pathindex]+
						                                            " not matching Regexp: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
					}
		    	} else {
		    		var feedback = context.walk.Terminal[0]==context.path[context.pathindex];
		    		if(!feedback){
		    			context.error={state:true,message:"Terminal "+context.path[context.pathindex]+
		    			                                            " not matching: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
		    		} else{
		    			fillcompiled(context,compiled,context.path[context.pathindex]);
		    		}
		    	}
		    } else {
		    	context.error={state:true,message:"ended prematurely"};
		    }
		    context.pathindex++;
		    context.compiled=compiled;
		    break;
		 case 'Stack':
		 case 'Sequence':
		 	var compiled = context.compiled;
		    for(var i=0; i<context.walk[walknodetype].length;i++){
		    	context.compiled=[];
		    	// console.log(walknodetype+" "+i);
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	dowalk(context);
		    	fillcompiled(context,compiled);	    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;
		    	if(context.error!==undefined) 
		    			break;
		    }
		    context.compiled=compiled;
		    break;
		 case 'Choice':
		    var skip=false;		    
		    var error=false;
		    var esindex=context.errorstack.length;
		    var compiled = context.compiled;		 
		    for(var i=1; i<context.walk[walknodetype].length;i++){
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	if(context.walk.Skip===undefined){
		    		var pathindex=context.pathindex;
		    		context.compiled=[];
					dowalk(context);
					if(context.error!==undefined){
						context.pathindex=pathindex;
						fillerrorstack(context);
						delete context.error;
						error=true;
					} else{ // success
						// console.log(walknodetype+" "+i);
		        		var restore = context.stack.pop();
		    			context.walk=restore.walk;
		    			context.walkindex=restore.walkindex;
		    			context.walkindex++;
		    			error=false;
		    			fillcompiled(context,compiled);    	
		    			break;							
					}
		    	} else{
		    		skip = true;
		    	}		    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;		    	
		    }
		    context.compiled=compiled;
		    if((skip)||(!error)){
		    	if(esindex==0){
					context.errorstack=[];
		    	} else {
		    		context.errorstack = context.errorstack.slice(0,esindex);
		    	}				
		    	return;
		    }		    	
		    context.error={state:true,message:"choice not satisfied near "+
		                                      context.path[context.pathindex]+
		                                      " in: "+context.titles[context.titles.length-1]};
		    break;
		 case 'Optional':
		    var skip=false;
		    var compiled = context.compiled;	
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk[walknodetype][0];
		    var pathindex = context.pathindex;
		    context.compiled=[];
			dowalk(context);
			if(context.error!==undefined){
				context.pathindex=pathindex;
				delete context.error;
				skip=true;
			} else{
				// success
		    	fillcompiled(context,compiled);	    	
			}	    	
	    	var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.compiled=compiled;
		    if(!skip) context.walkindex++;		    			   	 
		 	break;
		 case 'OneOrMore':
		 case 'ZeroOrMore':
		    var more = true;
		    var compiled = context.compiled;
		    do{
		    	for(var i=0; i<context.walk[walknodetype].length;i++){
		    		var pathindex=context.pathindex;
		        	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    		context.walkindex=0;
		    		context.walk=context.walk[walknodetype][i];
		    		context.compiled=[];
		    		dowalk(context);
		        	var restore = context.stack.pop();
		    		context.walk=restore.walk;
		    		context.walkindex=restore.walkindex;
		    		context.walkindex++;
		    		if(i==0){		    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
		    				// this is an error if context.walk[walknodetype].length == 2
		    				if((context.walk[walknodetype].length==2)&&(walknodetype=='OneOrMore')){
		    					more=false;
		    					break;		    					
		    				} else {
		    					// just the end = success
		    					// console.log(walknodetype+" "+i);
		    					fillcompiled(context,compiled);	    	
								context.pathindex=pathindex;
								delete context.error;
		    					more=false;
		    					break;		    					
		    				}
		    			} else{
		    				fillcompiled(context,compiled);	
		    			}
		    		} else if(i==1){		    			
		    			// just the end	    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
							context.pathindex=pathindex;
							delete context.error;
		    				more=false;
		    				break;
		    			} else{
		    				// success: another one!
		    				fillcompiled(context,compiled);		    	
		    			}
		    		}
		    	}
		    } while(more);
		    context.compiled=compiled;
		    break;
		 default:
		    context.error={state:true,message:"wrong walk node type :"+walknodetype};
		 	return;
	}
}
</script>
</body>
</html>
