<html>
<head>
<title>RailRoad live (SRFB)</title>
<link rel="stylesheet" href="codemirror.css">
<link rel="stylesheet" href="foldgutter.css">
<link rel="stylesheet" href="vis.css">
<script src="codemirror.js"></script>
<script src="matchbrackets.js"></script>
<script src="continuecomment.js"></script>
<script src="comment.js"></script>
<script src="foldcode.js"></script>
<script src="javascript.js"></script>
<script src="sql.js"></script>
<script src="foldgutter.js"></script>
<script src="brace-fold.js"></script>
<script src="json-formatter-js.js"></script>
<script src="railroad.js"></script>
<script src="jslint.js"></script>
<script src="vis.js"></script>
<script src="grammars.js"></script>
<script src="esprima.js"></script>
<script>
/* user application */
root.context =	{
		title:"notset",
		href:true,
		dochref:"doc"
	};
root.Railroad.call(this,root,
	{ // those will be Diagram options
	VERTICAL_SEPARATION: 8,
	ARC_RADIUS: 10,
	DIAGRAM_CLASS: 'railroad-diagram',
	STROKE_ODD_PIXEL_LENGTH: true,
	INTERNAL_ALIGNMENT: 'center',
	},
	root.context
);
</script>
<style>
body {
font-family : Arial, Helvetica, sans-serif;
}
.hidden{
	display: none;
}
a.svg {
  position: relative;
  display: inline-block;
}
svg.railroad-diagram {
    background-color: hsl(30,20%,95%);
}
svg.railroad-diagram path {
    stroke-width: 3;
    stroke: black;
    fill: rgba(0,0,0,0);
}
svg.railroad-diagram text {
    font: bold 14px monospace;
    text-anchor: middle;
}
svg.railroad-diagram text.diagram-text {
    font-size: 12px;
}
svg.railroad-diagram text.diagram-arrow {
    font-size: 16px;
}
svg.railroad-diagram text.label {
    text-anchor: start;
}
svg.railroad-diagram text.comment {
    font: italic 12px monospace;
}
svg.railroad-diagram g.non-terminal text {
    /*font-style: italic;*/
}
svg.railroad-diagram rect {
    stroke-width: 3;
    stroke: black;
    fill: hsl(120,100%,90%);
}
svg.railroad-diagram path.diagram-text {
    stroke-width: 3;
    stroke: black;
    fill: white;
    cursor: help;
}
svg.railroad-diagram g.diagram-text:hover path.diagram-text {
    fill: #eee;
}
input[type=checkbox]:checked + div,
input[type=checkbox]:checked + small + div {
  display: none;
}
.homeLink{
  background-color: #E4F5F8;
  border:1px solid #C0DEED; 
  text-decoration:none; 
}
header,
section,
aside,
nav,
footer {
  /* margin: 0 1.5% 24px 1.5%; */
}
section {
  float: left;
  width: 63%;
}
aside {
  float: right;
  width: 30%;
}
header{
  color:white;
  background-color:lightgrey;	
}
footer {
  clear: both;
  margin-bottom: 0;
  color:white;
  background-color:grey;
}
</style>
</head>
<body  onload="refresh()">
<div class="container">

<header>
<h1>railroad-diagram</h1>
</header>
<nav>
<a href="Documentation.html" target="_blank">
<input type="button" class="button" value="Help" />
</a>
<button id="dosetup" onclick="dosetup();">Setup</button>
<button id="dorailroard" onclick="dorailroad();">RailRoad Grammar</button>
<button id="doebnf" onclick="doebnf();">EBNF Grammar</button>
<button id="createtable" onclick="createtable();">Create Table</button>
<button id="expression" onclick="expression();">expression</button>
<button id="showhide" onclick="showhide();">show/hide</button>
<select id="items" onchange="goToItem()"></select>
<button id="switch" onclick="doswitch();">switch</button>
<button id="validate" onclick="dovalidate();">validate</button>
<button id="refresh" onclick="refresh();">refresh</button>
</nav>
<hr/>
<!-- navigation -->
<div>
<input type='checkbox' id='home'/>home(+/-)<small><span id="lc"></span></small>
<div>
<div id="editor">
<textarea id="graphin" cols='150' rows='25'>
</textarea>
<hr/>
<!-- grammar editor input -->
</div >
<div id="sql">
<textarea id="sqleditor" cols="50" rows="25">
</textarea>
<!-- expression to validate editor -->
<hr/>
</div>
<section>
<div id="treeresult">
</div>
</section>
<aside>
<div id="sqlcompiled">
</div>
</aside>
<!-- compiled result -->
<div id="setup">
<textarea id="setuptextarea" cols='150' rows='25'>
</textarea>
<hr/>
<!-- setup editor input -->
</div >
</div>
<div>
<div id="error">
</div>
<!-- errors output -->
<div id="result">
</div>
<!-- results -->
</div>
<section style="width:100%;">
<hr/>
<div id="alabnf">
</div>
</section>
<!-- a la bnf -->
<footer>
<small>Copyright &copy; Gilbert Brault 2016,2017
&nbsp;&nbsp;&nbsp;license&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://creativecommons.org/licenses/by/4.0/"><img src="images/cc.logo.white.svg" width="5%"/></a>
&nbsp;&nbsp;&nbsp;&nbsp;Original work from tabatkins&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/tabatkins/railroad-diagrams">(svg graphs)</a>
<small>
</footer>
<script>
window.addEventListener('message', function(event) {
	if(event.srcElement.location.href==window.location.href){
		editor.getDoc().setValue(event.data);
		sql.getDoc().setValue("/*  input your expression */");
		results.grammar="custom";
		refresh();
	}
});

window.editor = CodeMirror.fromTextArea(document.getElementById("graphin"), {
		mode: "javascript",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter",	
});

window.sql = CodeMirror.fromTextArea(document.getElementById("sqleditor"), {
		mode: "sql",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter"       
});

window.setupeditor = CodeMirror.fromTextArea(document.getElementById("setuptextarea"), {
		mode: "javascript",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter"       
});
window.results={};

var source=grammars.createtable.source;
var example=grammars.createtable.example;
var grammar="createtable";
window.editor.getDoc().setValue(source);
window.sql.getDoc().setValue(example);
window.results.grammar=grammar;

var cmsql = document.getElementById("sql");
cmsql.setAttribute("class","hidden");
window.showstate="editor";
var validate=document.getElementById("validate");
validate.setAttribute("class","hidden");
var setup = document.getElementById("setup");
setup.setAttribute("class","hidden");

var setupblob={validating:"function"};

window.editor.on("cursorActivity",function(instance){
	updatecursor(instance);
});
window.sql.on("cursorActivity",function(instance){
	updatecursor(instance);
});
window.setupeditor.on("cursorActivity",function(instance){
	updatecursor(instance);
});

function updatecursor(instance){
	var cursor = instance.getDoc().getCursor();
	// console.log(JSON.stringify(cursor));
	var lc = document.getElementById('lc');
	// search token
	var token=-1;
	var linefound=false;
	var charfound = false;
	var ptoken;
	if((instance===window.sql)&&((window.results!==undefined)&&(window.results.context!==undefined)&&(window.results.context.path!==undefined))){
		for(var i=0;i<window.results.context.path.length;i++){
			ptoken = window.results.context.path[i];
			var lineschars = window.results.context.lineschars[ptoken.index];
			if(lineschars.line==(cursor.line+1)){
				linefound=true;
			}
			if(linefound){
				if(lineschars.char>=(cursor.ch+1)){
					charfound=true;
					token=i;
					break;
				}
			}
		}
	}
	if(token==-1){
		lc.innerHTML=" line("+(cursor.line+1)+")- char("+(cursor.ch+1)+")";
	} else {
		lc.innerHTML=" line("+(cursor.line+1)+")- char("+(cursor.ch+1)+") token:"+ptoken.value+"("+token+")";
	}	
}

function dosetup(){
	var setup = document.getElementById("setup");
	var show = setup.getAttribute("class");

    if(show=='hidden'){
		setup.setAttribute("class","");
		window.setupeditor.getDoc().setValue(JSON.stringify(setupblob));
	} else {
		setup.setAttribute("class","hidden");
		setupblob=JSON.parse(window.setupeditor.getValue());
	}
}

function createtable(){
	window.editor.getDoc().setValue(grammars.createtable.source);
	window.sql.getDoc().setValue(grammars.createtable.example);
	window.results.grammar="createtable";
}

function expression(){
	window.editor.getDoc().setValue(grammars.expression.source);
	window.sql.getDoc().setValue(grammars.expression.example);
	window.results.grammar="expression";
}

function dorailroad(){
	window.editor.getDoc().setValue(grammars.railroad.source);
	window.sql.getDoc().setValue(grammars.expression.source);
	window.results.grammar="railroad";
}

function doebnf(){
	window.editor.getDoc().setValue(grammars.ebnf.source);
	window.sql.getDoc().setValue(grammars.ebnf.example);
	window.results.grammar="ebnf";
}

function injectjs(content,error){
    var scriptref=document.createElement('script');
    scriptref.setAttribute("type","text/javascript");
	var source = "try {\n"+content+"\n} catch(e) {\n";
	source +="    error.innerHTML='<pre>'+\n   e.stack+\n   '<\pre>'\n}";
    scriptref.innerText= source;
	window.error=error;
    if ((typeof scriptref!="undefined") && scriptref!=null){
    	try{
        	document.getElementsByTagName("head")[0].appendChild(scriptref);
    	} 	catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
    }
    return scriptref;
}

function _Show(){
	if(this.state==="graphing"){
		try{		
			this.graph.push ((new Diagram([].slice.call(arguments))).format());
		}  	catch(e){
			this.error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
		this.title.push(this.context.title);
		this.context.title="notset";
	} else if(this.state==="walking"){
		this.walk.push (Diagram(arguments[0]));
	} else if(this.state==="generating"){
		var res = Diagram(arguments[0]);
		var fname=normalize(this.context.fname); // we have to have a title in a Diagram! 
		eval("var "+fname+"=function(){return "+res+";}")
		this.context.language[fname]=eval(fname);
	} else if(this.state==="bnf"){
		var res = Diagram(arguments[0]);
		var tmp = {};
		tmp[this.context.fname]=res;
		this.context.bnf.push(tmp);
	}
}

function normalize(str){
	str=str.replace(/\s/g,'_');
	str=str.replace(/\-/g,'_');
	return "RR_"+str;
}

function refresh(){
	var error=document.getElementById('error');
	var result=document.getElementById('result');
	var select=document.getElementById('items');
	var alabnf = document.getElementById('alabnf');
	root.context.language={};
	root.context.bnf=[];
	window.results.title=[];
	window.results.graph=[];
	window.results.walk=[];
	window.results.context=root.context;
	window.results.state="notset";
	window.results.error=error;
	window.results.context.normalize=normalize;
	window.Show=_Show.bind(window.results);
	result.innerHTML="";
	error.innerHTML="";
	select.innerHTML="";
	alabnf.innerHTML="";
	var diags = window.editor.getValue();
	var scriptref;

	//jslint for errors
	var source = diags;
	source+="\nfunction Show(){}\n";
	for(var fn=0; fn<root.Railroad.fnames.length;fn++){
		source+="\nfunction "+root.Railroad.fnames[fn]+"(){}\n";
	}
	
	/* verify javascript */
	var eresult;
	var options={};
	var jserror=false;
	// var jscheck = jslint(source);  => using jslint library
	// error = jscheck.stop;
	
	/* using esprima */
	try {
		eresult = esprima.parse(source, options);
	} catch (e) {
		jserror=true;
		error.innerHTML  = e.name + ': ' + e.message;;
	}
	/* end using esprima */

	if(!jserror){

	// prepare graphing
	results.state='graphing';
	root.Railroad.SetExports(root.Railroad.graphing,root.Railroad.fnames);
	// comments should be within /* */  double // don't work
	try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}      
	scriptref.outerHTML="";

	// prepare json
	results.state='walking';
    root.Railroad.SetExports(root.Railroad.walking,root.Railroad.fnames);
    try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";

	// prepare generating
	results.state='generating';
	root.Railroad.SetExports(root.Railroad.generating,root.Railroad.fnames);
	try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";
	
	// prepare a la bnf
	results.state='bnf';
	root.Railroad.SetExports(root.Railroad.bnf,root.Railroad.fnames);
	try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";
	
	// render a la bnf
	{		
		const formatter = new JSONFormatter(results.context.bnf);
		var elt = formatter.render();
		alabnf.appendChild(elt);
	}

    // render results
    for(var i=0; i<results.graph.length;i++){
    		var section = document.createElement('section');
	        // show/hide
	        var home=document.createElement('a');
	        home.setAttribute("href","#");
	        home.setAttribute("onclick","home()");
	        home.setAttribute("class","homeLink");
	        home.setAttribute("title","jump to top");
	        var lhome=document.createTextNode("^");
	        home.appendChild(lhome);
	        section.appendChild(home);           
    		var checkbox = document.createElement('input');
			checkbox.type = "checkbox";
			section.appendChild(checkbox);
			var clabel= ((results.title[i]!=="notset")?results.title[i]:"")+" (+/-)";
			if(context.title!=="notset"){
            	checkbox.setAttribute("id",results.title[i]);
            	var option = document.createElement("option");
				option.text = results.title[i];
				select.add(option);
        	} 
        	var label=document.createTextNode(clabel);
        	section.appendChild(label);
        	var div = document.createElement('div');
        	section.appendChild(div);
        	if(i<results.graph.length-1)
        		checkbox.checked=true;

    		// graphing
			var graphout = document.createElement('aside');           
            graphout.appendChild(results.graph[i].toSVG());
			// graphout.appendChild(document.createTextNode(results.graph[i].toString()));
            div.appendChild(graphout);    	
			// json tree
		    const formatter = new JSONFormatter(results.walk[i]);
            var elt = formatter.render();
            var walkout = document.createElement('article');                       
            walkout.appendChild(elt);
            div.appendChild(walkout);
			result.appendChild(section);
    } 
	} else {
		// display warnings (//jslint)
		/*
		var content="<pre>";		
		for(var i=0; i<jscheck.warnings.length; i++){
			var w = jscheck.warnings[i];
			content+=w.line+":"+w.column+" "+w.message+"\n";
		}
		content+="</pre>";
		error.innerHTML=content;
		*/
	}        
}

function showhide(){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		chkbx.checked = ! chkbx.checked;
	}
}

function home(){
	document.getElementById("home").scrollIntoView();  
}

function scrollto(h){
	document.getElementById(h).scrollIntoView();  
}

function goToItem(){
	var select = document.getElementById("items");
	var item = select.value;
	_goToItem(item);
}

function _goToItem(item){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		if(item!=window.results.title[i]){
			chkbx.checked = true;
		} else {
			chkbx.checked = false;
		}
		
	}	
}

function doc(type,node){
	if(type==="NonTerminal"){
		_goToItem(node);
	}
}

function tokenizer(str){
/* add characters if more needed*/
const regex = /\/\*.*\*\/|'[^']*'|\/\*(?:[^/]*\n?)*\*\/|"[^"]*"|[A-Za-z][A-Za-z0-9_]*|:=|[,;\+\-\\\*\/()=\[\]\{\}\|.\?\:]|[0-9]+/gm;
var m;
var results=[];
var tokens=[];
var lineschars=[];

while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
        regex.lastIndex++;
    }
    
    // The result can be accessed through the `m`-variable.
    m.forEach((match, groupIndex) => {
        // console.log(`Found match, group ${groupIndex}: ${match}`);		
        if(!match.startsWith('/*')){
        		tokens.push({value:match,index:results.length});
        }
		results.push(match);
    });
}
/* list lines and start char */
var strindex=0;
var line=1;
var more=true;
var startline=0;

for(var resultsindex=0;resultsindex<results.length;resultsindex++){
	lineschars.push({line:line,char:(strindex-startline+1)});
	// I need to count \n in the token (else line numbers are wrong)
	line+=occurrences(str.substr(strindex,results[resultsindex].length-1), '\n', false);
	strindex+=results[resultsindex].length;
	more=true;
	while(more){
		if(strindex<str.length-1){
			switch(str.substr(strindex)[0]){
				case '\r':
				case '\t':
				case ' ':
			   		strindex++;
			   		break;
				case '\n':
			   		strindex++;
			   		line++;
			   		startline=strindex;
			   		break;
				default:
			   more=false;
			} 
		} else {
		  more=false;
		}		
	}
}

return {results,tokens,lineschars};	
}

/** Function that count occurrences of a substring in a string;
 * @param {String} string               The string
 * @param {String} subString            The sub string to search for
 * @param {Boolean} [allowOverlapping]  Optional. (Default:false)
 *
 * @author Vitim.us https://gist.github.com/victornpb/7736865
 * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/
 * @see http://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string/7924240#7924240
 */
function occurrences(string, subString, allowOverlapping) {

    string += "";
    subString += "";
    if (subString.length <= 0) return (string.length + 1);

    var n = 0,
        pos = 0,
        step = allowOverlapping ? 1 : subString.length;

    while (true) {
        pos = string.indexOf(subString, pos);
        if (pos >= 0) {
            ++n;
            pos += step;
        } else break;
    }
    return n;
}

function fillerrorstack(context){
	if(context.error!==undefined){
		var esindex = context.errorstack.length-1;
		if( (esindex!==-1) &&
		   (context.errorstack[esindex].state==context.error.state) &&
		   (context.errorstack[esindex].message==context.error.message)
		  ) return;
		context.errorstack.push({state:context.error.state,message:context.error.message});
	}
}

function doswitch(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var treeresult=document.getElementById('treeresult');
	treeresult.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var cmsql=document.getElementById("sql");
	var cmrailroad=document.getElementById("editor");
	var validate=document.getElementById("validate");
	var refresh=document.getElementById("refresh");

    if(window.showstate==="editor"){
		cmsql.setAttribute("class","");
		cmrailroad.setAttribute("class","hidden");
		validate.setAttribute("class","");
		refresh.setAttribute("class","hidden");
		window.showstate="sql";
	} else if(window.showstate==="sql"){
		cmsql.setAttribute("class","hidden");
		cmrailroad.setAttribute("class","");
		validate.setAttribute("class","hidden");
		refresh.setAttribute("class","");	
		window.showstate="editor";		
	}
}

function dovalidate(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var treeresult=document.getElementById('treeresult');
	treeresult.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var sql = window.sql.getValue();
	var tokenizerout = tokenizer(sql);
	var tokens=tokenizerout.tokens;
	var i;
	var walk;
	// now check if the path i.e. the tokens list is compatible with the selected graph
	// find the entry graph
	var select = document.getElementById("items");
	var item = select.value;
	for(i=0; i<window.results.title.length;i++){
		if(item===window.results.title[i]) break;
	}
	if(i<window.results.title.length){
		if(setupblob.validating=='tree'){
			walk = window.results.walk[i];
			var walkindex = 0;
			var pathindex = 0;
			var context = {path:tokens,pathindex:pathindex,walk:walk,walkindex:walkindex,titles:[item],lineschars:tokenizerout.lineschars};
			context.nonTerminals={};
			for(i=0; i<window.results.title.length;i++){
				context.nonTerminals[window.results.title[i]]=window.results.walk[i];
			}
			dowalk(context);
			var final={};
			final[item]=context.compiled;
			context.compiled=[];
			context.compiled.push(final);
			if(context.error===undefined){
				// displayed 'compiled' structure		
				const formatter = new JSONFormatter(context.compiled);
				var elt = formatter.render();
				sqlcompiled.appendChild(elt);
			} else{
				// display error and errorstack
				error.innerHTML=context.error.message;
				const formatter = new JSONFormatter(context.errorstack);
				var elt = formatter.render();
				error.appendChild(elt);
			}		
		} else if(setupblob.validating=='function'){
			root.Railroad.SetExports(root.Railroad.validating,root.Railroad.fnames);
			var funame = normalize(item);
			var fun = window.results.context.language[funame];
			if((fun!==undefined)&&(typeof fun ==='function')){
				window.results.context.path=tokens;
				window.results.context.pathindex=0;
				window.results.context.lineschars=tokenizerout.lineschars;
				window.results.context.compiled=[];
				window.results.context.compiledindex=0;
				window.results.context.stack=[item];
				var result=root.Railroad.execute(fun);
				if(result.error===undefined){
					// displayed 'compiled' structure		
					const formatter = new JSONFormatter(window.results.context.compiled);
					var elt = formatter.render();
					sqlcompiled.appendChild(elt);
					// display associated graph
					displaygraph(treeresult,window.results.context);
					if(window.results.grammar==='ebnf'){
						// generate SRFB grammar from EBNF
						// walk context.result_tree to generate the SRFB grammar
						window.SRFBfromEBNF = generateSRFB(window.results.context.result_tree);
						// sqlcompiled.innerHTML="<pre>"+SRFBfromEBNF+"</pre>";
						var win = window.open(window.location.href, '_blank');	
						setTimeout(function(){
									win.postMessage(SRFBfromEBNF,"*")
							},1000);
						win.focus();
					}
				} else{
					// display error and errorstack
					error.innerHTML=result.error;
				}		
			}
		}
	}
	return false;
}

function generateSRFB(EBFNtree){
	var ctx = {tree:EBFNtree,node:EBFNtree[0],result:""};
	walkEBNF(ctx);
	return ctx.result;
}

function walkEBNF(ctx){
	var node = ctx.node;
	var count = ctx.result.length;
	var args =[];
	switch(node.name){
	case 'syntax_':
		for(var i=0;i<node.childs.length;i++){
			if(node.childs[i].name==='production_'){
				ctx.node=node.childs[i];
				walkEBNF(ctx);
			}
		}
		ctx.node=node;
		break;
	case "expression_":
		ctx.node=node.childs[0];  // which is a choice
		walkEBNF(ctx);
		ctx.node=node;
		break;
	case "term_":
		ctx.node=node.childs[0];  // which is a sequence
		walkEBNF(ctx);
		ctx.node=node;		
		break;
	case "group_":
		ctx.node=node.childs[1];  // which is a sequence or a choice
		walkEBNF(ctx);
		ctx.node=node;		
		break;
	case "oneormore_":
		ctx.node=node.childs[1]; 
		walkEBNF(ctx);
		ctx.node=node;
		var send=ctx.result;
		if(count!=0){
			if(ctx.result.length>count){
				send= ctx.result.substr(count);
			} else {
				send ="";
			}				
			ctx.result=ctx.result.substr(0,count);				
		} else {
			ctx.result="";
		}
		ctx.result+= "ZeroOrMore("+send+")";  // in fact it's ZeroOrMore
		break;
	case "optional_":
		for(var i=0; i< node.childs.length; i+=3){
			count = ctx.result.length;
			ctx.node=node.childs[i+1]; 
			walkEBNF(ctx);
			ctx.node=node;
			var send=ctx.result;
			if(count!=0){
				if(ctx.result.length>count){
					send= ctx.result.substr(count);
				} else {
					send ="";
				}				
				ctx.result=ctx.result.substr(0,count);				
			} else {
				ctx.result="";
			}
			if(i>0){
				ctx.result+=",";
			}
			ctx.result+= "Optional("+send+")";
		}
		break;
	case 'production_':
		for(var i=0; i<node.childs.length; i+=4){
			for(j=0;j<4;j++){
				ctx.node=node.childs[i+j];					
				args.push(ctx.result.length);
				walkEBNF(ctx);
			}
			var production = node.childs[i].childs[0].name;
			var arguments=ctx.result.substr(args[2],args[3]-args[2]);
			ctx.result=ctx.result.substr(0,args[0]);
			ctx.result+="/*****************************************************************/\n";
			ctx.result+="Show(Stack(Title('"+production+"'),\n";
			ctx.result+=arguments+",\n";
			ctx.result+="Comment('END "+production+"' )\n)\n";
			ctx.result+="); /* "+production+" */\n";
			args =[];
			count = ctx.result.length;
		}
		ctx.node=node;
		break;
	case "sequence_":
		if(node.childs[0].childs.length==1){  // look for factor_ childs
			ctx.node=node.childs[0].childs[0];
			walkEBNF(ctx);
			break;
		} else {
			args.push(ctx.result.length);
			for(var i=0; i<node.childs[0].childs.length; i++){			
				ctx.node=node.childs[0].childs[i];
				walkEBNF(ctx);
				args.push(ctx.result.length);
			}
			ctx.node=node;
			var arguments='Sequence(';
			for(var i=0; i<node.childs[0].childs.length; i++){
				arguments+=(ctx.result.substr(args[i],args[i+1]-args[i]));
				if(i<node.childs[0].childs.length-1) 
						arguments+=',';
			}
			arguments+=')\n';
			if(count==0){
				ctx.result="";
			} else {
				ctx.result=ctx.result.substr(0,count);
			}
			ctx.result += arguments;			
		}		
		ctx.node=node;
		break;
	case "choice_":
		if(node.childs.length==1){
			ctx.node=node.childs[0];
			walkEBNF(ctx);
			break;
		} else {
			args.push(ctx.result.length);
			for(var i=0; i<node.childs.length; i++){
				if(i%2==0){					
					ctx.node=node.childs[i];
					walkEBNF(ctx);
					args.push(ctx.result.length);
				}
			}
			ctx.node=node;
			var arguments='Choice(0,\n';
			for(var i=0; i<node.childs.length; i++){
			    if(i%2==0){
					arguments+=(ctx.result.substr(args[i/2],args[i/2+1]-args[i/2]));
					if(i<node.childs.length-1) 
						arguments+=',\n';
				}
			}
			arguments+=')';
			if(count==0){
				ctx.result="";
			} else {
				ctx.result=ctx.result.substr(0,count);
			}
			ctx.result += arguments;
		}
		break;
	case "factor_":
	case "identifier_":
	case "literal_":
	case "title_":
	case "comment_":
		var index = ctx.result.length;
		for(var i=0; i<node.childs.length; i++){
			ctx.node=node.childs[i];			
			args.push(ctx.result.length);
			walkEBNF(ctx);
			var send=ctx.result;
			if(count!=0){
				if(ctx.result.length>count){
					send= ctx.result.substr(count);
				} else {
					send ="";
				}				
				ctx.result=ctx.result.substr(0,count);				
			} else {
				ctx.result="";
			}
			switch(node.name){
				case "factor_":
					ctx.result+=send;
					break;
				case "identifier_":
					ctx.result+="NonTerminal('"+send+"')";
					break;
				case "literal_":
					ctx.result+="Terminal("+send+")";
					break;
				case "comment_":
					ctx.result+="Comment("+send+")";
					break;
				case "title_":
					break;
			}
			if(i<node.childs.length-1) ctx.result+=",";	
			count = ctx.result.length;			
		}
		if(node.childs.length>1){
			var send=ctx.result;
			if(index!=0){
				if(ctx.result.length>index){
					send= ctx.result.substr(index);
				} else {
					send ="";
				}				
				ctx.result=ctx.result.substr(0,index);				
			} else {
				ctx.result="";
			}
			ctx.result+="Sequence("+send+")";
		}
		ctx.node=node;
		break;
	default:
		ctx.result += ctx.node.name;
		ctx.node=node;
	}
}

function addtotree(ctx){
    if((ctx.pparent==null)||(ctx.pparent.name!=ctx.datanodes[ctx.j])){
		var title="t:"+ctx.i+" l:"+ctx.data[ctx.i].line+" c:"+ctx.data[ctx.i].char;
		var node = {id:(ctx.id++),name:ctx.datanodes[ctx.j],parent:ctx.pparent,childs:[]};
		node.title=title;
		ctx.ptree.push(node);
		ctx.pparent=node;
		ctx.ptree=node.childs;
	}
	addTerminaltoTree(ctx);
}

function addTerminaltoTree(ctx){
	if(ctx.j==(ctx.datanodes.length-1)){
		var title="t:"+ctx.i+" l:"+ctx.data[ctx.i].line+" c:"+ctx.data[ctx.i].char;
		var node = {id:(ctx.id++),name:ctx.data[ctx.i].PathItem,parent:ctx.pparent};
		node.title=title;
		ctx.ptree.push(node);
	}
}

function dtreewalk(ctx){
	if(ctx.node===undefined) return;
	ctx.nodes.push({id:ctx.node.id,label:ctx.node.name,hidden: false,title:ctx.node.title});
	if(ctx.node.parent!=null){
		var id=""+ctx.node.parent.id+"-"+ctx.node.id;
		ctx.edges.push({id:id,from:ctx.node.parent.id,to:ctx.node.id,label:ctx.node.id,hidden: false});
	} 
	if(ctx.node.childs!==undefined){
		for(var i=0; i<ctx.node.childs.length; i++){
			dtreewalk({tree:ctx.tree,nodes:ctx.nodes,edges:ctx.edges,node:ctx.node.childs[i]});
		}
	}
}

function displaygraph(elt,context){
	// build nodes and edges
	var data = context.compiled
	var tree=[];
	var edges=[];
	var nodes=[];
	var ctx={ptree:null, pparent:null, datanodes:null,j:0,data:data,i:0, id:1};
	context.result_tree=tree;
	for(var i=0; i<data.length; i++){
		ctx.datanodes = data[i].level.split(":");
		ctx.ptree = tree;
		ctx.pparent=null;
		for(var j=0; j<ctx.datanodes.length; j++){  // j is the level		
			if(ctx.ptree.length==0){
				ctx.i=i;ctx.j=j;
				addtotree(ctx);				
			} else if(ctx.ptree[ctx.ptree.length-1].name==ctx.datanodes[j]){
				ctx.pparent=ctx.ptree[ctx.ptree.length-1];
				ctx.ptree=ctx.pparent.childs;
				if(ctx.ptree[ctx.ptree.length-1].childs==undefined){  // terminal node
					ctx.i=i;ctx.j=j;
					addtotree(ctx);				
				} else {
					if(j==(ctx.datanodes.length-1)){
						ctx.i=i;ctx.j=j;
						addtotree(ctx);										
					}
				}
			} else {
					ctx.i=i;ctx.j=j;
					addtotree(ctx);				
			}
		}		
	}
	
	dtreewalk({tree:tree,nodes:nodes,edges:edges,node:tree[0]});
	
	var options={
		layout: {
                    hierarchical: {
			sortMethod:'directed',
                        direction: 'LR', //'UD'
			parentCentralization: true
                    }
                }
	};
	
	nodes = new vis.DataSet(nodes);
	edges = new vis.DataSet(edges);
	var datanetwork={nodes,edges};
	var network=new vis.Network(elt,datanetwork,options);
	
	network.on("click", function(e) {
		var node = dtreefind(e.nodes[0],tree);
		if((node!==undefined)&&(node!=null)){
			if(node.hidden==undefined){
				node.hidden=true;
			} else {
				node.hidden=!node.hidden;
			}
			var ctx={current:node,parent:node,nodes:[],edges:[]};
			dtreehide(ctx);
			nodes.update(ctx.nodes);
			edges.update(ctx.edges);
		}
	});
}

function dtreehide(ctx){
	if(ctx.current!=ctx.parent){
		// build nodes and edges
		ctx.nodes.push({id:ctx.current.id, hidden:ctx.parent.hidden});
		var id=""+ctx.current.parent.id+"-"+ctx.current.id;
		ctx.edges.push({id:id,hidden:ctx.parent.hidden});
	} else {
		if(ctx.parent.hidden){
			ctx.nodes.push({id:ctx.parent.id,label:ctx.parent.name+"+"});
		} else {
			ctx.nodes.push({id:ctx.parent.id,label:ctx.parent.name});
		}
	}
	// do it for all childs as well
	var current = ctx.current;
	if(current.childs!==undefined){
		for(var i=0; i< current.childs.length; i++){		
			ctx.current=current.childs[i];
			dtreehide(ctx);		
		}
	}
	ctx.current = current;
}

function dtreefind(id,tree){
	for(var i=0; i<tree.length; i++){
		if(tree[i].id==id){
			return tree[i];
		} else {
			if(tree[i].childs!==undefined){
				var node = dtreefind(id,tree[i].childs);
				if(node!==null)
					return node;
			}
		}
	}
	return null;
}

function fillcompiled(context,compiled,nt){
	if(nt===undefined){
		if((Array.isArray(context.compiled) && (context.compiled.length>0))){
			if(context.compiled.length==1){
				compiled.push(context.compiled[0]);
			} else{
				compiled.push(context.compiled);
			}
		}
	} else if (!Array.isArray(context.compiled)){
		var keys = Object.keys(context.compiled);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(context.compiled[keys[i]])){
				if(context.compiled[keys[i]].length==1){
					context.compiled[keys[i]]= context.compiled[keys[i]][0];
				} else if(context.compiled[keys[i]].length==0){
					delete(context.compiled[keys[i]]);
				}
			}
		}
		if(Array.isArray(context.compiled)||(Object.keys(context.compiled).length!=0)){
			compiled.push(context.compiled);	
		}			
	} else{
		var keys = Object.keys(nt);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(nt[keys[i]])){
				if(nt[keys[i]].length==1){
					nt[keys[i]]= nt[keys[i]][0];
				} else if(nt[keys[i]].length==0){
					delete(nt[keys[i]]);
				}
			}
		}
		if(Array.isArray(nt)||(Object.keys(nt).length!=0)){
			compiled.push(nt);
		}		
	}
}

function dowalk(context){
	if (context.walkindex>Object.keys(context.walk).length) return;
	var walknodetype = Object.keys(context.walk)[context.walkindex];
	// context.errorstack=[];  // reset errorstack as it's relevant just for the current case (not global)
	switch(walknodetype){
		case 'Diagram':
			if(context.titles===undefined){
		    	context.titles=[];
		    }
			if(context.compiled===undefined){
				context.compiled = [];
			}
		    if (context.stack===undefined){
		    	context.stack = [];
		    }
		    if (context.errorstack===undefined){
		    	context.errorstack = [];
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk['Diagram'][0];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    return;
			break;
		case 'Title':
		    context.walkindex++;
		    break;
		 case 'Comment':
		    context.walkindex++;
		    break;	
		 case 'NonTerminal':
		  	var compiled = context.compiled;	
		  	var ntname=context.walk["NonTerminal"][0];
		  	// console.log(ntname);
		  	context.titles.push(ntname);
		    if(context.nonTerminals[context.walk["NonTerminal"][0]]===undefined){
		    	context.error={state:true,message:"not existing NonTerminal"+context.walk["NonTerminal"][0]};
		    	break;
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walk=context.nonTerminals[context.walk["NonTerminal"][0]];
		    var nt ={};
		    nt[ntname]=context.compiled=[];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    if(context.error===undefined) {
		    	fillcompiled(context,compiled,nt);	    		
		    }
		    context.compiled=compiled;
		    context.titles.pop();
		 	break;		    	 	
		 case 'Terminal':
		 	var compiled = context.compiled;	
		    if(context.pathindex<context.path.length){
		    	if(context.walk.Terminal[0].startsWith("/")){
		    		var l = context.walk.Terminal[0].length;
                  	const regex = new RegExp(context.walk.Terminal[0].substring(1,l-1));
					var m;

					if ((m = regex.exec(context.path[context.pathindex].value)) !== null) {
    					// The result can be accessed through the `m`-variable.
    					// m.forEach((match, groupIndex) => {
        					// console.log(`Found match, group ${groupIndex}: ${match}`);
    					// });
    					fillcompiled(context,compiled,context.path[context.pathindex]);
					} else {
						context.error={state:true,message:"Terminal "+context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.path[context.pathindex].index].line+
		                                      						" chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+		    			
		    			                                            " not matching: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
					}
		    	} else {
		    		var feedback = context.walk.Terminal[0]==context.path[context.pathindex].value;
		    		if(!feedback){
		    			context.error={state:true,message:"Terminal "+context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.path[context.pathindex].index].line+
		                                      						" chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+		    			
		    			                                            " not matching: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
		    		} else{
		    			fillcompiled(context,compiled,context.path[context.pathindex]);
		    		}
		    	}
		    } else {
		    	context.error={state:true,message:"ended prematurely expected:"+context.walk.Terminal[0]+
		    														"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.pathindex].line+
		                                      						" chars:"+context.lineschars[context.pathindex].char+"-"
		    				  };
		    }
		    context.pathindex++;
		    context.compiled=compiled;
		    break;
		 case 'Stack':
		 case 'Sequence':
		 	var compiled = context.compiled;
		    for(var i=0; i<context.walk[walknodetype].length;i++){
		    	context.compiled=[];
		    	// console.log(walknodetype+" "+i);
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	dowalk(context);
		    	fillcompiled(context,compiled);	    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;
		    	if(context.error!==undefined) 
		    			break;
		    }
		    context.compiled=compiled;
		    break;
		 case 'Choice':
		    var skip=false;		    
		    var error=false;
		    var esindex=context.errorstack.length;
		    var compiled = context.compiled;		 
		    for(var i=1; i<context.walk[walknodetype].length;i++){
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	if(context.walk.Skip===undefined){
		    		var pathindex=context.pathindex;
		    		context.compiled=[];
					dowalk(context);
					if(context.error!==undefined){
						context.pathindex=pathindex;
						fillerrorstack(context);
						delete context.error;
						error=true;
					} else{ // success
						// console.log(walknodetype+" "+i);
		        		var restore = context.stack.pop();
		    			context.walk=restore.walk;
		    			context.walkindex=restore.walkindex;
		    			context.walkindex++;
		    			error=false;
		    			fillcompiled(context,compiled);    	
		    			break;							
					}
		    	} else{
		    		skip = true;
		    	}		    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;		    	
		    }
		    context.compiled=compiled;
		    if((skip)||(!error)){
		    	if(esindex==0){
					context.errorstack=[];
		    	} else {
		    		context.errorstack = context.errorstack.slice(0,esindex);
		    	}				
		    	return;
		    }		    	
		    context.error={state:true,message:"choice not satisfied near "+
		                                      context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      context.lineschars[context.path[context.pathindex].index].line+
		                                      " chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+
		                                      " in: "+context.titles[context.titles.length-1]};
		    break;
		 case 'Optional':
		    var skip=false;
		    var compiled = context.compiled;	
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk[walknodetype][0];
		    var pathindex = context.pathindex;
		    context.compiled=[];
			dowalk(context);
			if(context.error!==undefined){
				context.pathindex=pathindex;
				delete context.error;
				skip=true;
			} else{
				// success
		    	fillcompiled(context,compiled);	    	
			}	    	
	    	var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.compiled=compiled;
		    if(!skip) context.walkindex++;		    			   	 
		 	break;
		 case 'OneOrMore':
		 case 'ZeroOrMore':
		    var more = true;
		    var compiled = context.compiled;
		    do{
		    	for(var i=0; i<context.walk[walknodetype].length;i++){
		    		if(context.pathindex==context.path.length){
		    			more = false;
		    			break;
		    		}
		    		var pathindex=context.pathindex;
		        	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    		context.walkindex=0;
		    		context.walk=context.walk[walknodetype][i];
		    		context.compiled=[];
		    		dowalk(context);
		        	var restore = context.stack.pop();
		    		context.walk=restore.walk;
		    		context.walkindex=restore.walkindex;
		    		context.walkindex++;
		    		if(i==0){		    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
		    				// this is an error if context.walk[walknodetype].length == 2
		    				if((context.walk[walknodetype].length==2)&&(walknodetype=='OneOrMore')){
		    					more=false;
		    					break;		    					
		    				} else {
		    					// just the end = success
		    					// console.log(walknodetype+" "+i);
		    					fillcompiled(context,compiled);	    	
								context.pathindex=pathindex;
								delete context.error;
		    					more=false;
		    					break;		    					
		    				}
		    			} else{
		    				fillcompiled(context,compiled);	
		    			}
		    		} else if(i==1){		    			
		    			// just the end	    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
							context.pathindex=pathindex;
							delete context.error;
		    				more=false;
		    				break;
		    			} else{
		    				// success: another one!
		    				fillcompiled(context,compiled);		    	
		    			}
		    		}
		    	}
		    } while(more);
		    context.compiled=compiled;
		    break;
		 default:
		    context.error={state:true,message:"wrong walk node type :"+walknodetype};
		 	return;
	}
}
</script>
</body>
</html>
