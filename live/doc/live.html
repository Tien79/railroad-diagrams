<html>
<head>
<title>RailRoad live (SRFB)</title>
<link rel="stylesheet" href="codemirror.css">
<link rel="stylesheet" href="foldgutter.css">
<script src="codemirror.js"></script>
<script src="matchbrackets.js"></script>
<script src="continuecomment.js"></script>
<script src="comment.js"></script>
<script src="foldcode.js"></script>
<script src="javascript.js"></script>
<script src="sql.js"></script>
<script src="foldgutter.js"></script>
<script src="brace-fold.js"></script>
<script src="json-formatter-js.js"></script>
<script src="railroad.js"></script>
<script src="jslint.js"></script>
<script>
window.expressionsource="/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('expression'),OneOrMore(NonTerminal('term'),Terminal('+')), Comment('END expression')) /* Sequence */ \n\
 ); /* expression */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('term'),OneOrMore(NonTerminal('factor'),Terminal('*')), Comment('END term')) /* Sequence */ \n\
 ); /* term */ \n\
/********************************************************************************************************************************/ \n\
 Show(Stack(Title('factor'),Sequence(Choice(0, \n\
                                   NonTerminal('constant'), \n\
                                   NonTerminal('variable'), \n\
                                   Sequence(Terminal('('),NonTerminal('expression'),Terminal(')')) \n\
                                  )) \n\
            , Comment('END factor')) /* Stack */ \n\
 ); /* factor */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('variable'),Terminal('/[A-Z][A-Za-z0-9_]*/'), Comment('END variable')) /* Sequence */ \n\
 ); /* variable */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('constant'),Terminal('/[+-]?[0-9]+/'), Comment('END constant')) /* Sequence */ \n\
 ); /* constant */ \n";
window.expressionexample="(Z+315)*(22+A)";
window.createtablesource= "/********************************************************************************************************************************/ \n\
Show(Stack(Title('CREATE TABLE'), \n\
  Sequence(Terminal('CREATE'),Choice(0,Skip(),Terminal('TEMP'),Terminal('TEMPORARY')),Terminal('TABLE'), \n\
           Optional(Sequence(Terminal('IF'),Terminal('NOT'),Terminal('EXISTS')) \n\
  ) /* sequence */ \n\
),Sequence(Optional(Sequence(NonTerminal('schema-name'),Terminal('.'))),NonTerminal('table-name')), /* sequence */ \n\
Sequence( \n\
 Choice(0, \n\
  Sequence(Terminal('('),OneOrMore(NonTerminal('column-def'),Terminal(',')), \n\
           ZeroOrMore(Terminal(','),NonTerminal('table-constraint')), \n\
           Terminal(')'),Optional(Sequence(Terminal('WITHOUT'),Terminal('ROWID')))), \n\
  Sequence(Terminal('AS'),NonImplemented('select-stm')) \n\
 ) /* choice */ \n\
), \n\
Comment('END CREATE TABLE')) /* Stack */ \n\
); /* Create Table */ \n\
/********************************************************************************************************************************/ \n\
Show( \n\
Sequence(Title('schema-name'), \n\
NonTerminal('name'),Comment('END schema-name') \n\
)  \n\
); /* schema name */ \n\
/********************************************************************************************************************************/ \n\
Show( \n\
Sequence(Title('table-name'),NonTerminal('name'),Comment('END table-name') \n\
) \n\
); /* tables name */ \n\
/********************************************************************************************************************************/ \n\
Show( \n\
Sequence(Title('column-def'),NonTerminal('column-name'),Optional(NonTerminal('type-name')),ZeroOrMore(NonTerminal('column-constraint')), \n\
Comment('END column-def') \n\
) \n\
); /* column def */ \n\
/********************************************************************************************************************************/ \n\
Show( \n\
Sequence(Title('column-name'),NonTerminal('name'),Comment('END column-name') \n\
) \n\
); /* column name */ \n\
/********************************************************************************************************************************/ \n\
Show( \n\
Sequence(Title('name'), \n\
Choice(0, \n\
	Terminal('/(^[A-Za-z][A-Za-z0-9_]*)/'), \n\
	Terminal('/(^\\\"[A-Za-z][A-Za-z0-9_\\s]*)\\\"/'), \n\
        Terminal(\"/(^\\'[A-Za-z][A-Za-z0-9_\\s]*)\\'/\") \n\
), \n\
Comment('END name') \n\
) \n\
); /* name */ \n\
/********************************************************************************************************************************/ \n\
Show(Stack( \n\
  Title('column-constraint'), \n\
  Optional(Sequence(Terminal('CONSTRAINT'),NonTerminal('name'))), \n\
  Sequence(Choice(0, \n\
         Sequence(Terminal('PRIMARY'),Terminal('KEY'),Choice(0,Skip(),Terminal('ASC'),Terminal('DESC')),NonTerminal('conflict-clause'),Optional(Terminal('AUTOINCREMENT'))), \n\
         Sequence(Optional(Terminal('NOT')),Terminal('NULL'),NonTerminal('conflict-clause')), \n\
         Sequence(Terminal('UNIQUE'),NonTerminal('conflict-clause')), \n\
         Sequence(Terminal('CHECK'),Terminal('('),NonImplemented('expr'),Terminal(')')), \n\
         Sequence(Terminal('DEFAULT'),Choice(0,NonTerminal('signed-number'),NonTerminal('literal-value'),Sequence(Terminal('('),NonImplemented('expr'),Terminal(')')))), \n\
         Sequence(Terminal('COLLATE'),Terminal('collation-name')), \n\
         NonTerminal('foreign-key-clause') \n\
        )), \n\
  Comment('END column-constraint') \n\
  ) \n\
); /* column-constraint */ \n\
/********************************************************************************************************************************/ \n\
Show(Sequence(Title('conflict-clause'), \n\
     Optional(Sequence(Terminal('ON'),Terminal('CONFLICT'), \n\
                                                Choice(0, \n\
                                                       Terminal('ROLLBACK'), \n\
                                                       Terminal('ABORT'), \n\
                                                       Terminal('FAIL'), \n\
                                                       Terminal('IGNORE'), \n\
                                                       Terminal('REPLACE')) \n\
                                               ) \n\
                                      ),Comment('END conflict-clause')) \n\
    ); /* conflict-clause */ \n\
/********************************************************************************************************************************/ \n\
Show(Stack(Title('table-constraint'),Stack(Optional(Sequence(Terminal('CONSTRAINT'),NonTerminal('name'))), \n\
                                     Choice(0,Sequence(Choice(0,Sequence(Terminal('PRIMARY'),Terminal('Key')),Terminal('UNIQUE')),Terminal('('), \n\
                                                       OneOrMore(NonTerminal('indexed-column'),Terminal(',')),Terminal(')'),NonTerminal('conflict-clause')), \n\
                                            Sequence(Terminal('CHECK'),Terminal('('),NonImplemented('expr'),Terminal(')')), \n\
                                            Sequence(Terminal('FOREIGN'),Terminal('KEY'),Terminal('('), \n\
                                                     OneOrMore(NonTerminal('column-name'),Terminal(',')),Terminal(')'), \n\
                                                     NonTerminal('foreign-key-clause')) \n\
                                           )                                           \n\
     ), \n\
     Comment('END table-constrainte')) \n\
); /* table-constraint */ \n\
/********************************************************************************************************************************/ \n\
Show(Stack(Title('indexed-column'), \n\
     Sequence(Choice(0,NonTerminal('column-name'),NonImplemented('expr')), \n\
              Optional(Sequence(Terminal('COLLATE'),NonTerminal('collation-name'))), \n\
              Choice(0,Skip(),Terminal('ASC'),Terminal('DESC'))), \n\
     Comment('END indexed-column')) \n\
    ); /* indexed-column */ \n\
/********************************************************************************************************************************/ \n\
Show(Stack(Title('type-name'), \n\
           Sequence(NonTerminal('name'),Choice(0, \n\
                                                Skip(), \n\
                                                Sequence(Terminal('('),NonTerminal('signed-number'),Terminal(')')), \n\
                                                Sequence(Terminal('('),NonTerminal('signed-number'),Terminal(','),NonTerminal('signed-number'),Terminal(')')) \n\
                                               ) \n\
                   ), \n\
           Comment('END type-name')) \n\
    ); /* type-name */  \n\
/********************************************************************************************************************************/ \n\
Show(Stack(Title('numeric-literal'), \n\
           Sequence(Choice(0,Choice(0,Sequence(Choice(0,Sequence(Terminal('/[0-9]+/'),Optional(Sequence(Terminal('.'),Terminal('/[0-9]+/')))), \n\
                                                      Sequence(Terminal('.'),Terminal('/[0-9]+/')) \n\
                                                     ), \n\
                                               Optional(Sequence(Terminal('E'), \n\
                                                                 Choice(0,Skip(),Terminal('+'),Terminal('-')),Terminal('/[0-9]+/'))) \n\
                                              ) \n\
                                   ), \n\
                           Sequence(Terminal('0x'),Terminal('/[A-Za-z0-9]+)/')) \n\
                          ) \n\
                   ), \n\
           Comment('END numeric-literal')) \n\
    ); /* numeric-literal */ \n\
/********************************************************************************************************************************/ \n\
Show(Sequence(Title('signed-number'),Optional(Choice(0,Terminal('+'),Terminal('-'))),NonTerminal('numeric-literal'),Comment('END signed-number')) \n\
    ); /* signed-number */  \n\
/********************************************************************************************************************************/ \n\
Show(Stack(Title('foreign-key-clause'), \n\
           Sequence(Terminal('REFERENCES'),NonTerminal('foreign-table'), \n\
                    Optional(Sequence(Terminal('('),OneOrMore(NonTerminal('column-name'),Terminal(',')),Terminal(')')))), \n\
           Stack(ZeroOrMore( \n\
                          Choice(0, \n\
                                 Sequence(Terminal('ON'), \n\
                                          Choice(0,Terminal('DELETE'),Terminal('UPDATE')), \n\
                                          Choice(0, \n\
                                                 Sequence(Terminal('SET'),Choice(0,Terminal('NULL'),Terminal('DEFAULT'))), \n\
                                                 Terminal('CASCADE'), \n\
                                                 Terminal('RESTRICT'), \n\
                                                 Sequence(Terminal('NO'),Terminal('ACTION')) \n\
                                                ) \n\
                                         ), \n\
                                 Sequence(Terminal('MATCH'),NonTerminal('name')) \n\
                                ) \n\
                          ), \n\
                          Optional(Sequence(Optional(Terminal('NOT')),Terminal('DEFERRABLE'), \n\
                                           Choice(0,Skip(),Sequence(Terminal('INITIALLY'), \n\
                                                                    Choice(0,Terminal('DEFFERED'),Terminal('IMMEDIATE')) \n\
                                                                   ) \n\
                                                 ) \n\
                                           ) \n\
                                  ) \n\
                   ), \n\
           Comment('END foreign-key-clause') \n\
          ) \n\
    ); /* foreign-key-clause */ \n\
/********************************************************************************************************************************/ \n\
Show(Sequence(Title('foreign-table'),NonTerminal('table-name'),Comment('END foreign-table')) \n\
    ); /* foreign-table */ ";

window.createtableexample= "CREATE TABLE \"Customer\" ( \n\
  \"IdCustomer\" text NULL PRIMARY KEY, \n\
  \"CompanyName\" text NULL, \n\
  \"ContactName\" text NULL, \n\
  \"ContactTitle\" text NULL, \n\
  \"Address\" text NULL, \n\
  \"City\" text NULL, \n\
  \"Region\" text NULL, \n\
  \"PostalCode\" text NULL, \n\
  \"Country\" text NULL, \n\
  \"Phone\" text NULL, \n\
  \"Fax\" text NULL \n\
) \n";

window.railroadsource = "/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('RailRoad'),OneOrMore(NonTerminal('Show'),Terminal(';')),Comment('END Railroad'))); \n\
/* Railroad */ \n\
/********************************************************************************************************************************/ \n\
 Show( \n\
 Sequence(Title('Show'),\n\
           Sequence(Terminal('Show'),Terminal('('),\n\
                   Choice(0,Sequence(NonTerminal('Title'),\n\
                                     Optional(Sequence(Terminal(','),NonTerminal('Childs'))), \n\
                                     Terminal(','),NonTerminal('Comment') \n\
                                    ), \n\
                          NonTerminal('Title Stack'),NonTerminal('Title Sequence')), \n\
                   Terminal(')') \n\
                  ), \n\
          Comment('END Show')) \n\
     ); \n\
/* Show */ \n\
/********************************************************************************************************************************/ \n\
 Show( \n\
 Sequence(Title('string'), \n\
 Choice(0, \n\
  		Terminal(\"/'(?:[^\\']|\\.)*'/\"), \n\
        Terminal('/\"(?:[^\\\"]|\\.)*\"/'), \n\
        Terminal(\"/[^'\\\"]+/\") \n\
 	   ), \n\
 Comment('END string') \n\
 ) \n\
 ); \n\
/* string */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('ordinal'), \n\
            Choice(0, \n\
                Terminal('0'), \n\
            	Sequence(Terminal('/[1-9]/'),Terminal('/[0-9]*/')) \n\
            ), \n\
            Comment('END ordinal')) \n\
     ); \n\
/* ordinal */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Title'), \n\
            Sequence(Terminal('Title'),Terminal('('),NonTerminal('string'),Terminal(')')), \n\
            Comment('END Title')) \n\
     ); \n\
/* Title */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Comment'), \n\
            Sequence(Terminal('Comment'),Terminal('('),NonTerminal('string'),Terminal(')')), \n\
            Comment('END Comment')) \n\
     ); \n\
/* Comment */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Title Stack'), \n\
            Stack(Sequence(Terminal('Stack'),Terminal('('),NonTerminal('Title')),\n\
                   Optional(Sequence(Terminal(','),NonTerminal('Childs'))),Terminal(')')), \n\
            Comment('END Title Stack')) \n\
     ); \n\
/* Title Stack */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Title Sequence'), \n\
            Stack(Sequence(Terminal('Sequence'),Terminal('('),NonTerminal('Title')),\n\
                  Optional(Sequence(Terminal(','),NonTerminal('Childs'))),Terminal(')')), \n\
            Comment('END Title Sequence')) \n\
     ); \n\
/* Title Sequence */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Childs'),OneOrMore(NonTerminal('Child'),Terminal(',')),Comment('END Childs'))); \n\
 /* Childs */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('TwoOrMoreChilds'),NonTerminal('Child'),Terminal(','),OneOrMore(NonTerminal('Child'),Terminal(',')),Comment('END TwoOrMoreChilds'))); \n\
 /* TwoOrMoreChilds */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Sequence'),Terminal('Sequence'),Terminal('('),NonTerminal('Childs'),Terminal(')'),Comment('END Sequence'))); \n\
 /* Sequence */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Stack'),Terminal('Stack'),Terminal('('),NonTerminal('Childs'),Terminal(')'),Comment('END Stack'))); \n\
 /* Stack */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Choice'),Terminal('Choice'),Terminal('('),NonTerminal('ordinal'),Terminal(','),NonTerminal('TwoOrMoreChilds'),Terminal(')'),Comment('END Choice'))); \n\
 /* Choice */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Optional'),Terminal('Optional'),Terminal('('),NonTerminal('Child'),Terminal(')'),Comment('END Optional'))); \n\
 /* Optional */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('OneOrMore'),Terminal('OneOrMore'),Terminal('('),NonTerminal('Child'),Terminal(','),NonTerminal('Child'),Terminal(')'),Comment('END OneOrMore'))); \n\
 /* OneOrMore */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('ZeroOrMore'),Terminal('ZeroOrMore'),Terminal('('),NonTerminal('Child'),Terminal(','),NonTerminal('Child'),Terminal(')'),Comment('END ZeroOrMore'))); \n\
 /* ZeroOrMore */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Terminal'), \n\
            Sequence(Terminal('Terminal'),Terminal('('),NonTerminal('string'),Terminal(')')), \n\
            Comment('END Terminal')) \n\
     ); \n\
/* Terminal */\n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('NonTerminal'), \n\
            Sequence(Terminal('NonTerminal'),Terminal('('),NonTerminal('string'),Terminal(')')), \n\
            Comment('END NonTerminal')) \n\
     ); \n\
/* NonTerminal */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('NonImplemented'), \n\
            Sequence(Terminal('NonImplemented'),Terminal('('),NonTerminal('string'),Terminal(')')), \n\
            Comment('END NonImplemented')) \n\
     ); \n\
/* NonImplemented */ \n\
/********************************************************************************************************************************/ \n\
 Show(Sequence(Title('Skip'), \n\
            Sequence(Terminal('Skip'),Terminal('('),Terminal(')')), \n\
            Comment('END Skip')) \n\
     ); \n\
/* Skip */ \n\
/********************************************************************************************************************************/\n\
Show(Sequence(Title('Child'), \n\
              Choice(0, \n\
                     NonTerminal('Sequence'), \n\
                     NonTerminal('Stack'), \n\
                     NonTerminal('Choice'), \n\
                     NonTerminal('Optional'), \n\
                     NonTerminal('OneOrMore'), \n\
                     NonTerminal('ZeroOrMore'), \n\
                     NonTerminal('Terminal'), \n\
                     NonTerminal('NonTerminal'), \n\
                     NonTerminal('Comment'), \n\
                     NonTerminal('Skip'), \n\
                     NonTerminal('NonImplemented') \n\
                    ), \n\
 Comment('END Child')) \n\
     ); \n\
/* Child */";

/* user application */
root.context =	{
		title:"notset",
		href:true,
		dochref:"doc"
	};
root.Railroad.call(this,root,
	{ // those will be Diagram options
	VERTICAL_SEPARATION: 8,
	ARC_RADIUS: 10,
	DIAGRAM_CLASS: 'railroad-diagram',
	STROKE_ODD_PIXEL_LENGTH: true,
	INTERNAL_ALIGNMENT: 'center',
	},
	root.context
);
</script>
<style>
body {
font-family : Arial, Helvetica, sans-serif;
}
.hidden{
	display: none;
}
a.svg {
  position: relative;
  display: inline-block;
}
svg.railroad-diagram {
    background-color: hsl(30,20%,95%);
}
svg.railroad-diagram path {
    stroke-width: 3;
    stroke: black;
    fill: rgba(0,0,0,0);
}
svg.railroad-diagram text {
    font: bold 14px monospace;
    text-anchor: middle;
}
svg.railroad-diagram text.diagram-text {
    font-size: 12px;
}
svg.railroad-diagram text.diagram-arrow {
    font-size: 16px;
}
svg.railroad-diagram text.label {
    text-anchor: start;
}
svg.railroad-diagram text.comment {
    font: italic 12px monospace;
}
svg.railroad-diagram g.non-terminal text {
    /*font-style: italic;*/
}
svg.railroad-diagram rect {
    stroke-width: 3;
    stroke: black;
    fill: hsl(120,100%,90%);
}
svg.railroad-diagram path.diagram-text {
    stroke-width: 3;
    stroke: black;
    fill: white;
    cursor: help;
}
svg.railroad-diagram g.diagram-text:hover path.diagram-text {
    fill: #eee;
}
input[type=checkbox]:checked + div,
input[type=checkbox]:checked + small + div {
  display: none;
}
.homeLink{
  background-color: #E4F5F8;
  border:1px solid #C0DEED; 
  text-decoration:none; 
}
header,
section,
aside,
nav,
footer {
  /* margin: 0 1.5% 24px 1.5%; */
}
section {
  float: left;
  width: 63%;
}
aside {
  float: right;
  width: 30%;
}
header{
  color:white;
  background-color:lightgrey;	
}
footer {
  clear: both;
  margin-bottom: 0;
  color:white;
  background-color:grey;
}
</style>
</head>
<body  onload="refresh()">
<div class="container">

<header>
<h1>railroad-diagram</h1>
</header>
<nav>
<a href="documentation.html" target="_blank">
<input type="button" class="button" value="Help" />
</a>
<button id="dosetup" onclick="dosetup();">Setup</button>
<button id="dorailroard" onclick="dorailroad();">RailRoad Grammar</button>
<button id="createtable" onclick="createtable();">Create Table</button>
<button id="expression" onclick="expression();">expression</button>
<button id="showhide" onclick="showhide();">show/hide</button>
<select id="items" onchange="goToItem()"></select>
<button id="switch" onclick="doswitch();">switch</button>
<button id="validate" onclick="dovalidate();">validate</button>
<button id="refresh" onclick="refresh();">refresh</button>
</nav>
<hr/>
<!-- navigation -->
<div>
<input type='checkbox' id='home'/>home(+/-)<small><span id="lc"></span></small>
<div>
<div id="editor">
<textarea id="graphin" cols='150' rows='25'>
</textarea>
<hr/>
<!-- grammar editor input -->
</div >
<div id="sql">
<textarea id="sqleditor" cols="50" rows="25">
</textarea>
<!-- expression to validate editor -->
<hr/>
</div>
<div id="sqlcompiled">
</div>
<!-- compiled result -->
<div id="setup">
<textarea id="setuptextarea" cols='150' rows='25'>
</textarea>
<hr/>
<!-- setup editor input -->
</div >
</div>
<div>
<div id="error">
</div>
<!-- errors output -->
<div id="result">
</div>
<!-- results -->
</div>
<section style="width:100%;">
<hr/>
<div id="alabnf">
</div>
</section>
<!-- a la bnf -->
<footer>
<small>Copyright &copy; Gilbert Brault 2016,2017
&nbsp;&nbsp;&nbsp;license&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://creativecommons.org/licenses/by/4.0/"><img src="https://creativecommons.org/wp-content/themes/cc/images/cc.logo.white.svg" width="5%"/></a>
&nbsp;&nbsp;&nbsp;&nbsp;Original work from tabatkins&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/tabatkins/railroad-diagrams">(svg graphs)</a>
<small>
</footer>
<script>

window.editor = CodeMirror.fromTextArea(document.getElementById("graphin"), {
		mode: "javascript",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter",	
});

window.sql = CodeMirror.fromTextArea(document.getElementById("sqleditor"), {
		mode: "sql",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter"       
});

window.setupeditor = CodeMirror.fromTextArea(document.getElementById("setuptextarea"), {
		mode: "javascript",
        lineNumbers: true,
        lineWrapping: true,
        matchBrackets: true,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
        continueComments: "Enter"       
});

window.editor.getDoc().setValue(window.createtablesource);
window.sql.getDoc().setValue(window.createtableexample);

var cmsql = document.getElementById("sql");
cmsql.setAttribute("class","hidden");
window.showstate="editor";
var validate=document.getElementById("validate");
validate.setAttribute("class","hidden");
var setup = document.getElementById("setup");
setup.setAttribute("class","hidden");

var setupblob={validating:"function"};

window.editor.on("cursorActivity",function(instance){
	updatecursor(instance);
});
window.sql.on("cursorActivity",function(instance){
	updatecursor(instance);
});
window.setupeditor.on("cursorActivity",function(instance){
	updatecursor(instance);
});

function updatecursor(instance){
	var cursor = instance.getDoc().getCursor();
	// console.log(JSON.stringify(cursor));
	var lc = document.getElementById('lc');
	// search token
	var token=-1;
	var linefound=false;
	var charfound = false;
	var ptoken;
	if((instance===window.sql)&&((window.results!==undefined)&&(window.results.context!==undefined)&&(window.results.context.path!==undefined))){
		for(var i=0;i<window.results.context.path.length;i++){
			ptoken = window.results.context.path[i];
			var lineschars = window.results.context.lineschars[ptoken.index];
			if(lineschars.line==(cursor.line+1)){
				linefound=true;
			}
			if(linefound){
				if(lineschars.char>=(cursor.ch+1)){
					charfound=true;
					token=i;
					break;
				}
			}
		}
	}
	if(token==-1){
		lc.innerHTML=" line("+(cursor.line+1)+")- char("+(cursor.ch+1)+")";
	} else {
		lc.innerHTML=" line("+(cursor.line+1)+")- char("+(cursor.ch+1)+") token:"+ptoken.value+"("+token+")";
	}	
}

function dosetup(){
	var setup = document.getElementById("setup");
	var show = setup.getAttribute("class");

    if(show=='hidden'){
		setup.setAttribute("class","");
		window.setupeditor.getDoc().setValue(JSON.stringify(setupblob));
	} else {
		setup.setAttribute("class","hidden");
		setupblob=JSON.parse(window.setupeditor.getValue());
	}
}

function createtable(){
	window.editor.getDoc().setValue(window.createtablesource);
	window.sql.getDoc().setValue(window.createtableexample);
}

function expression(){
	window.editor.getDoc().setValue(window.expressionsource);
	window.sql.getDoc().setValue(window.expressionexample);
}

function dorailroad(){
	window.editor.getDoc().setValue(window.railroadsource);
	window.sql.getDoc().setValue(window.expressionsource);
}

function injectjs(content,error){
    var scriptref=document.createElement('script');
    scriptref.setAttribute("type","text/javascript");
    scriptref.innerText= content;
    if ((typeof scriptref!="undefined") && scriptref!=null){
    	try{
        	document.getElementsByTagName("head")[0].appendChild(scriptref);
    	} 	catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
    }
    return scriptref;
}

function _Show(){
	if(this.state==="graphing"){
		try{		
			this.graph.push ((new Diagram([].slice.call(arguments))).format());
		}  	catch(e){
			this.error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	    }    
		this.title.push(this.context.title);
		this.context.title="notset";
	} else if(this.state==="walking"){
		this.walk.push (Diagram(arguments[0]));
	} else if(this.state==="generating"){
		var res = Diagram(arguments[0]);
		var fname=normalize(this.context.fname); // we have to have a title in a Diagram! 
		eval("var "+fname+"=function(){return "+res+";}")
		this.context.language[fname]=eval(fname);
	} else if(this.state==="bnf"){
		var res = Diagram(arguments[0]);
		var tmp = {};
		tmp[this.context.fname]=res;
		this.context.bnf.push(tmp);
	}
}

function normalize(str){
	str=str.replace(/\s/g,'_');
	str=str.replace(/\-/g,'_');
	return "RR_"+str;
}

function refresh(){
	var error=document.getElementById('error');
	var result=document.getElementById('result');
	var select=document.getElementById('items');
	var alabnf = document.getElementById('alabnf');
	root.context.language={};
	root.context.bnf=[];
	window.results={title:[],graph:[],walk:[],context:root.context,state:"notset",error:error};
	window.results.context.normalize=normalize;
	window.Show=_Show.bind(window.results);
	result.innerHTML="";
	error.innerHTML="";
	select.innerHTML="";
	alabnf.innerHTML="";
	var diags = window.editor.getValue();
	var scriptref;

	//jslint for errors
	var source = diags;
	source+="\nfunction Show(){}\n";
	for(var fn=0; fn<root.Railroad.fnames.length;fn++){
		source+="\nfunction "+root.Railroad.fnames[fn]+"(){}\n";
	}
	var jscheck = jslint(source);

	if(!jscheck.stop){

	// prepare graphing
	results.state='graphing';
	root.Railroad.SetExports(root.Railroad.graphing,root.Railroad.fnames);
	// comments should be within /* */  double // don't work
	try{
		scriptref = injectjs(diags,error);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}      
	scriptref.outerHTML="";

	// prepare json
	results.state='walking';
    root.Railroad.SetExports(root.Railroad.walking,root.Railroad.fnames);
    try{
		scriptref = injectjs(diags);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";

	// prepare generating
	results.state='generating';
	root.Railroad.SetExports(root.Railroad.generating,root.Railroad.fnames);
	try{
		scriptref = injectjs(diags);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";
	
	// prepare a la bnf
	results.state='bnf';
	root.Railroad.SetExports(root.Railroad.bnf,root.Railroad.fnames);
	try{
		scriptref = injectjs(diags);
	} catch(e){
		error.innerHTML="<pre>"+
					    e.stack+"\n"+
						"</pre>";
	}
	scriptref.outerHTML="";
	
	// render a la bnf
	{		
		const formatter = new JSONFormatter(results.context.bnf);
		var elt = formatter.render();
		alabnf.appendChild(elt);
	}

    // render results
    for(var i=0; i<results.graph.length;i++){
    		var section = document.createElement('section');
	        // show/hide
	        var home=document.createElement('a');
	        home.setAttribute("href","#");
	        home.setAttribute("onclick","home()");
	        home.setAttribute("class","homeLink");
	        home.setAttribute("title","jump to top");
	        var lhome=document.createTextNode("^");
	        home.appendChild(lhome);
	        section.appendChild(home);           
    		var checkbox = document.createElement('input');
			checkbox.type = "checkbox";
			section.appendChild(checkbox);
			var clabel= ((results.title[i]!=="notset")?results.title[i]:"")+" (+/-)";
			if(context.title!=="notset"){
            	checkbox.setAttribute("id",results.title[i]);
            	var option = document.createElement("option");
				option.text = results.title[i];
				select.add(option);
        	} 
        	var label=document.createTextNode(clabel);
        	section.appendChild(label);
        	var div = document.createElement('div');
        	section.appendChild(div);
        	if(i<results.graph.length-1)
        		checkbox.checked=true;

    		// graphing
			var graphout = document.createElement('aside');           
            graphout.appendChild(results.graph[i].toSVG());
			// graphout.appendChild(document.createTextNode(results.graph[i].toString()));
            div.appendChild(graphout);    	
			// json tree
		    const formatter = new JSONFormatter(results.walk[i]);
            var elt = formatter.render();
            var walkout = document.createElement('article');                       
            walkout.appendChild(elt);
            div.appendChild(walkout);
			result.appendChild(section);
    } 
	} else {
		// display warnings
		var content="<pre>";		
		for(var i=0; i<jscheck.warnings.length; i++){
			var w = jscheck.warnings[i];
			content+=w.line+":"+w.column+" "+w.message+"\n";
		}
		content+="</pre>";
		error.innerHTML=content;
	}        
}

function showhide(){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		chkbx.checked = ! chkbx.checked;
	}
}

function home(){
	document.getElementById("home").scrollIntoView();  
}

function scrollto(h){
	document.getElementById(h).scrollIntoView();  
}

function goToItem(){
	var select = document.getElementById("items");
	var item = select.value;
	_goToItem(item);
}

function _goToItem(item){
	for(var i=0; i< window.results.title.length; i++){
		var chkbx = document.getElementById(window.results.title[i]);
		if(item!=window.results.title[i]){
			chkbx.checked = true;
		} else {
			chkbx.checked = false;
		}
		
	}	
}

function doc(type,node){
	if(type==="NonTerminal"){
		_goToItem(node);
	}
}

function tokenizer(str){
/* add characters if more needed*/
const regex = /"\/.*\/"|'\/.*\/'|\/\*.*\*\/|"[^"]*"|'[^']*'|[A-Za-z][A-Za-z09_]*|[,;\+\*/()]|[0-9]+/gm;
var m;
var results=[];
var tokens=[];
var lineschars=[];

while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
        regex.lastIndex++;
    }
    
    // The result can be accessed through the `m`-variable.
    m.forEach((match, groupIndex) => {
        // console.log(`Found match, group ${groupIndex}: ${match}`);		
        if(!match.startsWith('/*')){
        		tokens.push({value:match,index:results.length});
        }
		results.push(match);
    });
}
/* list lines and start char */
var strindex=0;
var line=1;
var more=true;
var startline=0;

for(var resultsindex=0;resultsindex<results.length;resultsindex++){
	lineschars.push({line:line,char:(strindex-startline+1)});
	strindex+=results[resultsindex].length;
	more=true;
	while(more){
		if(strindex<str.length-1){
			switch(str.substr(strindex)[0]){
				case '\r':
				case '\t':
				case ' ':
			   		strindex++;
			   		break;
				case '\n':
			   		strindex++;
			   		line++;
			   		startline=strindex;
			   		break;
				default:
			   more=false;
			} 
		} else {
		  more=false;
		}		
	}
}

return {results,tokens,lineschars};	
}

function fillerrorstack(context){
	if(context.error!==undefined){
		var esindex = context.errorstack.length-1;
		if( (esindex!==-1) &&
		   (context.errorstack[esindex].state==context.error.state) &&
		   (context.errorstack[esindex].message==context.error.message)
		  ) return;
		context.errorstack.push({state:context.error.state,message:context.error.message});
	}
}

function doswitch(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var cmsql=document.getElementById("sql");
	var cmrailroad=document.getElementById("editor");
	var validate=document.getElementById("validate");
	var refresh=document.getElementById("refresh");

    if(window.showstate==="editor"){
		cmsql.setAttribute("class","");
		cmrailroad.setAttribute("class","hidden");
		validate.setAttribute("class","");
		refresh.setAttribute("class","hidden");
		window.showstate="sql";
	} else if(window.showstate==="sql"){
		cmsql.setAttribute("class","hidden");
		cmrailroad.setAttribute("class","");
		validate.setAttribute("class","hidden");
		refresh.setAttribute("class","");	
		window.showstate="editor";		
	}
}

function dovalidate(){
	var sqlcompiled=document.getElementById('sqlcompiled');
	sqlcompiled.innerHTML="";
	var error=document.getElementById('error');
	error.innerHTML="";
	var sql = window.sql.getValue();
	var tokenizerout = tokenizer(sql);
	var tokens=tokenizerout.tokens;
	var i;
	var walk;
	// now check if the path i.e. the tokens list is compatible with the selected graph
	// find the entry graph
	var select = document.getElementById("items");
	var item = select.value;
	for(i=0; i<window.results.title.length;i++){
		if(item===window.results.title[i]) break;
	}
	if(i<window.results.title.length){
		if(setupblob.validating=='tree'){
			walk = window.results.walk[i];
			var walkindex = 0;
			var pathindex = 0;
			var context = {path:tokens,pathindex:pathindex,walk:walk,walkindex:walkindex,titles:[item],lineschars:tokenizerout.lineschars};
			context.nonTerminals={};
			for(i=0; i<window.results.title.length;i++){
				context.nonTerminals[window.results.title[i]]=window.results.walk[i];
			}
			dowalk(context);
			var final={};
			final[item]=context.compiled;
			context.compiled=[];
			context.compiled.push(final);
			if(context.error===undefined){
				// displayed 'compiled' structure		
				const formatter = new JSONFormatter(context.compiled);
				var elt = formatter.render();
				sqlcompiled.appendChild(elt);
			} else{
				// display error and errorstack
				error.innerHTML=context.error.message;
				const formatter = new JSONFormatter(context.errorstack);
				var elt = formatter.render();
				error.appendChild(elt);
			}		
		} else if(setupblob.validating=='function'){
			root.Railroad.SetExports(root.Railroad.validating,root.Railroad.fnames);
			var funame = normalize(item);
			var fun = window.results.context.language[funame];
			if((fun!==undefined)&&(typeof fun ==='function')){
				window.results.context.path=tokens;
				window.results.context.pathindex=0;
				window.results.context.lineschars=tokenizerout.lineschars;
				window.results.context.compiled=[];
				window.results.context.compiledindex=0;
				window.results.context.stack=[item];
				var result=root.Railroad.execute(fun);
				if(result.error===undefined){
					// displayed 'compiled' structure		
					const formatter = new JSONFormatter(window.results.context.compiled);
					var elt = formatter.render();
					sqlcompiled.appendChild(elt);
				} else{
					// display error and errorstack
					error.innerHTML=result.error;
				}		
			}
		}
	}
	return false;
}

function fillcompiled(context,compiled,nt){
	if(nt===undefined){
		if((Array.isArray(context.compiled) && (context.compiled.length>0))){
			if(context.compiled.length==1){
				compiled.push(context.compiled[0]);
			} else{
				compiled.push(context.compiled);
			}
		}
	} else if (!Array.isArray(context.compiled)){
		var keys = Object.keys(context.compiled);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(context.compiled[keys[i]])){
				if(context.compiled[keys[i]].length==1){
					context.compiled[keys[i]]= context.compiled[keys[i]][0];
				} else if(context.compiled[keys[i]].length==0){
					delete(context.compiled[keys[i]]);
				}
			}
		}
		if(Array.isArray(context.compiled)||(Object.keys(context.compiled).length!=0)){
			compiled.push(context.compiled);	
		}			
	} else{
		var keys = Object.keys(nt);
		for(var i=0;i<keys.length;i++){
			if(Array.isArray(nt[keys[i]])){
				if(nt[keys[i]].length==1){
					nt[keys[i]]= nt[keys[i]][0];
				} else if(nt[keys[i]].length==0){
					delete(nt[keys[i]]);
				}
			}
		}
		if(Array.isArray(nt)||(Object.keys(nt).length!=0)){
			compiled.push(nt);
		}		
	}
}

function dowalk(context){
	if (context.walkindex>Object.keys(context.walk).length) return;
	var walknodetype = Object.keys(context.walk)[context.walkindex];
	// context.errorstack=[];  // reset errorstack as it's relevant just for the current case (not global)
	switch(walknodetype){
		case 'Diagram':
			if(context.titles===undefined){
		    	context.titles=[];
		    }
			if(context.compiled===undefined){
				context.compiled = [];
			}
		    if (context.stack===undefined){
		    	context.stack = [];
		    }
		    if (context.errorstack===undefined){
		    	context.errorstack = [];
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk['Diagram'][0];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    return;
			break;
		case 'Title':
		    context.walkindex++;
		    break;
		 case 'Comment':
		    context.walkindex++;
		    break;	
		 case 'NonTerminal':
		  	var compiled = context.compiled;	
		  	var ntname=context.walk["NonTerminal"][0];
		  	// console.log(ntname);
		  	context.titles.push(ntname);
		    if(context.nonTerminals[context.walk["NonTerminal"][0]]===undefined){
		    	context.error={state:true,message:"not existing NonTerminal"+context.walk["NonTerminal"][0]};
		    	break;
		    }
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walk=context.nonTerminals[context.walk["NonTerminal"][0]];
		    var nt ={};
		    nt[ntname]=context.compiled=[];		    
		    dowalk(context);
		    var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.walkindex++;
		    if(context.error===undefined) {
		    	fillcompiled(context,compiled,nt);	    		
		    }
		    context.compiled=compiled;
		    context.titles.pop();
		 	break;		    	 	
		 case 'Terminal':
		 	var compiled = context.compiled;	
		    if(context.pathindex<context.path.length){
		    	if(context.walk.Terminal[0].startsWith("/")){
		    		var l = context.walk.Terminal[0].length;
                  	const regex = new RegExp(context.walk.Terminal[0].substring(1,l-1));
					var m;

					if ((m = regex.exec(context.path[context.pathindex].value)) !== null) {
    					// The result can be accessed through the `m`-variable.
    					// m.forEach((match, groupIndex) => {
        					// console.log(`Found match, group ${groupIndex}: ${match}`);
    					// });
    					fillcompiled(context,compiled,context.path[context.pathindex]);
					} else {
						context.error={state:true,message:"Terminal "+context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.path[context.pathindex].index].line+
		                                      						" chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+		    			
		    			                                            " not matching: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
					}
		    	} else {
		    		var feedback = context.walk.Terminal[0]==context.path[context.pathindex];
		    		if(!feedback){
		    			context.error={state:true,message:"Terminal "+context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.path[context.pathindex].index].line+
		                                      						" chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+		    			
		    			                                            " not matching: "+context.walk.Terminal[0]+
						                                            " in: "+context.titles[context.titles.length-1]};
		    		} else{
		    			fillcompiled(context,compiled,context.path[context.pathindex]);
		    		}
		    	}
		    } else {
		    	context.error={state:true,message:"ended prematurely expected:"+context.walk.Terminal[0]+
		    														"("+context.pathindex+")-lines:"+
		                                      						context.lineschars[context.pathindex].line+
		                                      						" chars:"+context.lineschars[context.pathindex].char+"-"
		    				  };
		    }
		    context.pathindex++;
		    context.compiled=compiled;
		    break;
		 case 'Stack':
		 case 'Sequence':
		 	var compiled = context.compiled;
		    for(var i=0; i<context.walk[walknodetype].length;i++){
		    	context.compiled=[];
		    	// console.log(walknodetype+" "+i);
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	dowalk(context);
		    	fillcompiled(context,compiled);	    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;
		    	if(context.error!==undefined) 
		    			break;
		    }
		    context.compiled=compiled;
		    break;
		 case 'Choice':
		    var skip=false;		    
		    var error=false;
		    var esindex=context.errorstack.length;
		    var compiled = context.compiled;		 
		    for(var i=1; i<context.walk[walknodetype].length;i++){
		    	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    	context.walkindex=0;
		    	context.walk=context.walk[walknodetype][i];
		    	if(context.walk.Skip===undefined){
		    		var pathindex=context.pathindex;
		    		context.compiled=[];
					dowalk(context);
					if(context.error!==undefined){
						context.pathindex=pathindex;
						fillerrorstack(context);
						delete context.error;
						error=true;
					} else{ // success
						// console.log(walknodetype+" "+i);
		        		var restore = context.stack.pop();
		    			context.walk=restore.walk;
		    			context.walkindex=restore.walkindex;
		    			context.walkindex++;
		    			error=false;
		    			fillcompiled(context,compiled);    	
		    			break;							
					}
		    	} else{
		    		skip = true;
		    	}		    	
		        var restore = context.stack.pop();
		    	context.walk=restore.walk;
		    	context.walkindex=restore.walkindex;
		    	context.walkindex++;		    	
		    }
		    context.compiled=compiled;
		    if((skip)||(!error)){
		    	if(esindex==0){
					context.errorstack=[];
		    	} else {
		    		context.errorstack = context.errorstack.slice(0,esindex);
		    	}				
		    	return;
		    }		    	
		    context.error={state:true,message:"choice not satisfied near "+
		                                      context.path[context.pathindex].value+"("+context.pathindex+")-lines:"+
		                                      context.lineschars[context.path[context.pathindex].index].line+
		                                      " chars:"+context.lineschars[context.path[context.pathindex].index].char+"-"+
		                                      " in: "+context.titles[context.titles.length-1]};
		    break;
		 case 'Optional':
		    var skip=false;
		    var compiled = context.compiled;	
		    context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    context.walkindex=0;
		    context.walk=context.walk[walknodetype][0];
		    var pathindex = context.pathindex;
		    context.compiled=[];
			dowalk(context);
			if(context.error!==undefined){
				context.pathindex=pathindex;
				delete context.error;
				skip=true;
			} else{
				// success
		    	fillcompiled(context,compiled);	    	
			}	    	
	    	var restore = context.stack.pop();
		    context.walk=restore.walk;
		    context.walkindex=restore.walkindex;
		    context.compiled=compiled;
		    if(!skip) context.walkindex++;		    			   	 
		 	break;
		 case 'OneOrMore':
		 case 'ZeroOrMore':
		    var more = true;
		    var compiled = context.compiled;
		    do{
		    	for(var i=0; i<context.walk[walknodetype].length;i++){
		    		if(context.pathindex==context.path.length){
		    			more = false;
		    			break;
		    		}
		    		var pathindex=context.pathindex;
		        	context.stack.push({walk:context.walk,walkindex:context.walkindex});
		    		context.walkindex=0;
		    		context.walk=context.walk[walknodetype][i];
		    		context.compiled=[];
		    		dowalk(context);
		        	var restore = context.stack.pop();
		    		context.walk=restore.walk;
		    		context.walkindex=restore.walkindex;
		    		context.walkindex++;
		    		if(i==0){		    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
		    				// this is an error if context.walk[walknodetype].length == 2
		    				if((context.walk[walknodetype].length==2)&&(walknodetype=='OneOrMore')){
		    					more=false;
		    					break;		    					
		    				} else {
		    					// just the end = success
		    					// console.log(walknodetype+" "+i);
		    					fillcompiled(context,compiled);	    	
								context.pathindex=pathindex;
								delete context.error;
		    					more=false;
		    					break;		    					
		    				}
		    			} else{
		    				fillcompiled(context,compiled);	
		    			}
		    		} else if(i==1){		    			
		    			// just the end	    			
		    			if(context.error!==undefined) {
		    				fillerrorstack(context);
							context.pathindex=pathindex;
							delete context.error;
		    				more=false;
		    				break;
		    			} else{
		    				// success: another one!
		    				fillcompiled(context,compiled);		    	
		    			}
		    		}
		    	}
		    } while(more);
		    context.compiled=compiled;
		    break;
		 default:
		    context.error={state:true,message:"wrong walk node type :"+walknodetype};
		 	return;
	}
}
</script>
</body>
</html>
